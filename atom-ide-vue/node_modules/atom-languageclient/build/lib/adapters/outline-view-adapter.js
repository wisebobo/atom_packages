"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const convert_1 = require("../convert");
const Utils = require("../utils");
const languageclient_1 = require("../languageclient");
const atom_1 = require("atom");
/**
 * Public: Adapts the documentSymbolProvider of the language server to the Outline View
 * supplied by Atom IDE UI.
 */
class OutlineViewAdapter {
    constructor() {
        this._cancellationTokens = new WeakMap();
    }
    /**
     * Public: Determine whether this adapter can be used to adapt a language server
     * based on the serverCapabilities matrix containing a documentSymbolProvider.
     *
     * @param serverCapabilities The {ServerCapabilities} of the language server to consider.
     * @returns A {Boolean} indicating adapter can adapt the server based on the
     *   given serverCapabilities.
     */
    static canAdapt(serverCapabilities) {
        return serverCapabilities.documentSymbolProvider === true;
    }
    /**
     * Public: Obtain the Outline for document via the {LanguageClientConnection} as identified
     * by the {TextEditor}.
     *
     * @param connection A {LanguageClientConnection} to the language server that will be queried
     *   for the outline.
     * @param editor The Atom {TextEditor} containing the text the Outline should represent.
     * @returns A {Promise} containing the {Outline} of this document.
     */
    getOutline(connection, editor) {
        return __awaiter(this, void 0, void 0, function* () {
            const results = yield Utils.doWithCancellationToken(connection, this._cancellationTokens, (cancellationToken) => connection.documentSymbol({ textDocument: convert_1.default.editorToTextDocumentIdentifier(editor) }, cancellationToken));
            if (results.length === 0) {
                return {
                    outlineTrees: [],
                };
            }
            if (results[0].selectionRange !== undefined) {
                // If the server is giving back the newer DocumentSymbol format.
                return {
                    outlineTrees: OutlineViewAdapter.createHierarchicalOutlineTrees(results),
                };
            }
            else {
                // If the server is giving back the original SymbolInformation format.
                return {
                    outlineTrees: OutlineViewAdapter.createOutlineTrees(results),
                };
            }
        });
    }
    /**
     * Public: Create an {Array} of {OutlineTree}s from the Array of {DocumentSymbol} recieved
     * from the language server. This includes converting all the children nodes in the entire
     * hierarchy.
     *
     * @param symbols An {Array} of {DocumentSymbol}s received from the language server that
     *   should be converted to an {Array} of {OutlineTree}.
     * @returns An {Array} of {OutlineTree} containing the given symbols that the Outline View can display.
     */
    static createHierarchicalOutlineTrees(symbols) {
        // Sort all the incoming symbols
        symbols.sort((a, b) => {
            if (a.range.start.line !== b.range.start.line) {
                return a.range.start.line - b.range.start.line;
            }
            if (a.range.start.character !== b.range.start.character) {
                return a.range.start.character - b.range.start.character;
            }
            if (a.range.end.line !== b.range.end.line) {
                return a.range.end.line - b.range.end.line;
            }
            return a.range.end.character - b.range.end.character;
        });
        return symbols.map((symbol) => {
            const tree = OutlineViewAdapter.hierarchicalSymbolToOutline(symbol);
            if (symbol.children != null) {
                tree.children = OutlineViewAdapter.createHierarchicalOutlineTrees(symbol.children);
            }
            return tree;
        });
    }
    /**
     * Public: Create an {Array} of {OutlineTree}s from the Array of {SymbolInformation} recieved
     * from the language server. This includes determining the appropriate child and parent
     * relationships for the hierarchy.
     *
     * @param symbols An {Array} of {SymbolInformation}s received from the language server that
     *   should be converted to an {OutlineTree}.
     * @returns An {OutlineTree} containing the given symbols that the Outline View can display.
     */
    static createOutlineTrees(symbols) {
        symbols.sort((a, b) => (a.location.range.start.line === b.location.range.start.line
            ? a.location.range.start.character - b.location.range.start.character
            : a.location.range.start.line - b.location.range.start.line));
        // Temporarily keep containerName through the conversion process
        // Also filter out symbols without a name - it's part of the spec but some don't include it
        const allItems = symbols.filter((symbol) => symbol.name).map((symbol) => ({
            containerName: symbol.containerName,
            outline: OutlineViewAdapter.symbolToOutline(symbol),
        }));
        // Create a map of containers by name with all items that have that name
        const containers = allItems.reduce((map, item) => {
            const name = item.outline.representativeName;
            if (name != null) {
                const container = map.get(name);
                if (container == null) {
                    map.set(name, [item.outline]);
                }
                else {
                    container.push(item.outline);
                }
            }
            return map;
        }, new Map());
        const roots = [];
        // Put each item within its parent and extract out the roots
        for (const item of allItems) {
            const containerName = item.containerName;
            const child = item.outline;
            if (containerName == null || containerName === '') {
                roots.push(item.outline);
            }
            else {
                const possibleParents = containers.get(containerName);
                let closestParent = OutlineViewAdapter._getClosestParent(possibleParents, child);
                if (closestParent == null) {
                    closestParent = {
                        plainText: containerName,
                        representativeName: containerName,
                        startPosition: new atom_1.Point(0, 0),
                        children: [child],
                    };
                    roots.push(closestParent);
                    if (possibleParents == null) {
                        containers.set(containerName, [closestParent]);
                    }
                    else {
                        possibleParents.push(closestParent);
                    }
                }
                else {
                    closestParent.children.push(child);
                }
            }
        }
        return roots;
    }
    static _getClosestParent(candidates, child) {
        if (candidates == null || candidates.length === 0) {
            return null;
        }
        let parent;
        for (const candidate of candidates) {
            if (candidate !== child &&
                candidate.startPosition.isLessThanOrEqual(child.startPosition) &&
                (candidate.endPosition === undefined ||
                    (child.endPosition && candidate.endPosition.isGreaterThanOrEqual(child.endPosition)))) {
                if (parent === undefined ||
                    (parent.startPosition.isLessThanOrEqual(candidate.startPosition) ||
                        (parent.endPosition != null &&
                            candidate.endPosition &&
                            parent.endPosition.isGreaterThanOrEqual(candidate.endPosition)))) {
                    parent = candidate;
                }
            }
        }
        return parent || null;
    }
    /**
     * Public: Convert an individual {DocumentSymbol} from the language server
     * to an {OutlineTree} for use by the Outline View. It does NOT recursively
     * process the given symbol's children (if any).
     *
     * @param symbol The {DocumentSymbol} to convert to an {OutlineTree}.
     * @returns The {OutlineTree} corresponding to the given {DocumentSymbol}.
     */
    static hierarchicalSymbolToOutline(symbol) {
        const icon = OutlineViewAdapter.symbolKindToEntityKind(symbol.kind);
        return {
            tokenizedText: [
                {
                    kind: OutlineViewAdapter.symbolKindToTokenKind(symbol.kind),
                    value: symbol.name,
                },
            ],
            icon: icon != null ? icon : undefined,
            representativeName: symbol.name,
            startPosition: convert_1.default.positionToPoint(symbol.selectionRange.start),
            endPosition: convert_1.default.positionToPoint(symbol.selectionRange.end),
            children: [],
        };
    }
    /**
     * Public: Convert an individual {SymbolInformation} from the language server
     * to an {OutlineTree} for use by the Outline View.
     *
     * @param symbol The {SymbolInformation} to convert to an {OutlineTree}.
     * @returns The {OutlineTree} equivalent to the given {SymbolInformation}.
     */
    static symbolToOutline(symbol) {
        const icon = OutlineViewAdapter.symbolKindToEntityKind(symbol.kind);
        return {
            tokenizedText: [
                {
                    kind: OutlineViewAdapter.symbolKindToTokenKind(symbol.kind),
                    value: symbol.name,
                },
            ],
            icon: icon != null ? icon : undefined,
            representativeName: symbol.name,
            startPosition: convert_1.default.positionToPoint(symbol.location.range.start),
            endPosition: convert_1.default.positionToPoint(symbol.location.range.end),
            children: [],
        };
    }
    /**
     * Public: Convert a symbol kind into an outline entity kind used to determine
     * the styling such as the appropriate icon in the Outline View.
     *
     * @param symbol The numeric symbol kind received from the language server.
     * @returns A string representing the equivalent OutlineView entity kind.
     */
    static symbolKindToEntityKind(symbol) {
        switch (symbol) {
            case languageclient_1.SymbolKind.Array:
                return 'type-array';
            case languageclient_1.SymbolKind.Boolean:
                return 'type-boolean';
            case languageclient_1.SymbolKind.Class:
                return 'type-class';
            case languageclient_1.SymbolKind.Constant:
                return 'type-constant';
            case languageclient_1.SymbolKind.Constructor:
                return 'type-constructor';
            case languageclient_1.SymbolKind.Enum:
                return 'type-enum';
            case languageclient_1.SymbolKind.Field:
                return 'type-field';
            case languageclient_1.SymbolKind.File:
                return 'type-file';
            case languageclient_1.SymbolKind.Function:
                return 'type-function';
            case languageclient_1.SymbolKind.Interface:
                return 'type-interface';
            case languageclient_1.SymbolKind.Method:
                return 'type-method';
            case languageclient_1.SymbolKind.Module:
                return 'type-module';
            case languageclient_1.SymbolKind.Namespace:
                return 'type-namespace';
            case languageclient_1.SymbolKind.Number:
                return 'type-number';
            case languageclient_1.SymbolKind.Package:
                return 'type-package';
            case languageclient_1.SymbolKind.Property:
                return 'type-property';
            case languageclient_1.SymbolKind.String:
                return 'type-string';
            case languageclient_1.SymbolKind.Variable:
                return 'type-variable';
            case languageclient_1.SymbolKind.Struct:
                return 'type-class';
            case languageclient_1.SymbolKind.EnumMember:
                return 'type-constant';
            default:
                return null;
        }
    }
    /**
     * Public: Convert a symbol kind to the appropriate token kind used to syntax
     * highlight the symbol name in the Outline View.
     *
     * @param symbol The numeric symbol kind received from the language server.
     * @returns A string representing the equivalent syntax token kind.
     */
    static symbolKindToTokenKind(symbol) {
        switch (symbol) {
            case languageclient_1.SymbolKind.Class:
                return 'type';
            case languageclient_1.SymbolKind.Constructor:
                return 'constructor';
            case languageclient_1.SymbolKind.Method:
            case languageclient_1.SymbolKind.Function:
                return 'method';
            case languageclient_1.SymbolKind.String:
                return 'string';
            default:
                return 'plain';
        }
    }
}
exports.default = OutlineViewAdapter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3V0bGluZS12aWV3LWFkYXB0ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9saWIvYWRhcHRlcnMvb3V0bGluZS12aWV3LWFkYXB0ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFDQSx3Q0FBaUM7QUFDakMsa0NBQWtDO0FBRWxDLHNEQU0yQjtBQUMzQiwrQkFHYztBQUVkOzs7R0FHRztBQUNILE1BQXFCLGtCQUFrQjtJQUF2QztRQUVVLHdCQUFtQixHQUErRCxJQUFJLE9BQU8sRUFBRSxDQUFDO0lBNFQxRyxDQUFDO0lBMVRDOzs7Ozs7O09BT0c7SUFDSSxNQUFNLENBQUMsUUFBUSxDQUFDLGtCQUFzQztRQUMzRCxPQUFPLGtCQUFrQixDQUFDLHNCQUFzQixLQUFLLElBQUksQ0FBQztJQUM1RCxDQUFDO0lBRUQ7Ozs7Ozs7O09BUUc7SUFDVSxVQUFVLENBQUMsVUFBb0MsRUFBRSxNQUFrQjs7WUFDOUUsTUFBTSxPQUFPLEdBQUcsTUFBTSxLQUFLLENBQUMsdUJBQXVCLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDLGlCQUFpQixFQUFFLEVBQUUsQ0FDOUcsVUFBVSxDQUFDLGNBQWMsQ0FBQyxFQUFFLFlBQVksRUFBRSxpQkFBTyxDQUFDLDhCQUE4QixDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsaUJBQWlCLENBQUMsQ0FDL0csQ0FBQztZQUVGLElBQUksT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7Z0JBQ3hCLE9BQU87b0JBQ0wsWUFBWSxFQUFFLEVBQUU7aUJBQ2pCLENBQUM7YUFDSDtZQUVELElBQUssT0FBTyxDQUFDLENBQUMsQ0FBb0IsQ0FBQyxjQUFjLEtBQUssU0FBUyxFQUFFO2dCQUMvRCxnRUFBZ0U7Z0JBQ2hFLE9BQU87b0JBQ0wsWUFBWSxFQUFFLGtCQUFrQixDQUFDLDhCQUE4QixDQUM3RCxPQUEyQixDQUFDO2lCQUMvQixDQUFDO2FBQ0g7aUJB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O2dCQUN6QixPQUFPLGFBQWEsQ0FBQztZQUN2QixLQUFLLDJCQUFVLENBQUMsTUFBTSxDQUFDO1lBQ3ZCLEtBQUssMkJBQVUsQ0FBQyxRQUFRO2dCQUN0QixPQUFPLFFBQVEsQ0FBQztZQUNsQixLQUFLLDJCQUFVLENBQUMsTUFBTTtnQkFDcEIsT0FBTyxRQUFRLENBQUM7WUFDbEI7Z0JBQ0UsT0FBTyxPQUFPLENBQUM7U0FDbEI7SUFDSCxDQUFDO0NBQ0Y7QUE5VEQscUNBOFRDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgYXRvbUlkZSBmcm9tICdhdG9tLWlkZSc7XG5pbXBvcnQgQ29udmVydCBmcm9tICcuLi9jb252ZXJ0JztcbmltcG9ydCAqIGFzIFV0aWxzIGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IENhbmNlbGxhdGlvblRva2VuU291cmNlIH0gZnJvbSAndnNjb2RlLWpzb25ycGMnO1xuaW1wb3J0IHtcbiAgTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLFxuICBTeW1ib2xLaW5kLFxuICBTZXJ2ZXJDYXBhYmlsaXRpZXMsXG4gIFN5bWJvbEluZm9ybWF0aW9uLFxuICBEb2N1bWVudFN5bWJvbCxcbn0gZnJvbSAnLi4vbGFuZ3VhZ2VjbGllbnQnO1xuaW1wb3J0IHtcbiAgUG9pbnQsXG4gIFRleHRFZGl0b3IsXG59IGZyb20gJ2F0b20nO1xuXG4vKipcbiAqIFB1YmxpYzogQWRhcHRzIHRoZSBkb2N1bWVudFN5bWJvbFByb3ZpZGVyIG9mIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdG8gdGhlIE91dGxpbmUgVmlld1xuICogc3VwcGxpZWQgYnkgQXRvbSBJREUgVUkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE91dGxpbmVWaWV3QWRhcHRlciB7XG5cbiAgcHJpdmF0ZSBfY2FuY2VsbGF0aW9uVG9rZW5zOiBXZWFrTWFwPExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbiwgQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2U+ID0gbmV3IFdlYWtNYXAoKTtcblxuICAvKipcbiAgICogUHVibGljOiBEZXRlcm1pbmUgd2hldGhlciB0aGlzIGFkYXB0ZXIgY2FuIGJlIHVzZWQgdG8gYWRhcHQgYSBsYW5ndWFnZSBzZXJ2ZXJcbiAgICogYmFzZWQgb24gdGhlIHNlcnZlckNhcGFiaWxpdGllcyBtYXRyaXggY29udGFpbmluZyBhIGRvY3VtZW50U3ltYm9sUHJvdmlkZXIuXG4gICAqXG4gICAqIEBwYXJhbSBzZXJ2ZXJDYXBhYmlsaXRpZXMgVGhlIHtTZXJ2ZXJDYXBhYmlsaXRpZXN9IG9mIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdG8gY29uc2lkZXIuXG4gICAqIEByZXR1cm5zIEEge0Jvb2xlYW59IGluZGljYXRpbmcgYWRhcHRlciBjYW4gYWRhcHQgdGhlIHNlcnZlciBiYXNlZCBvbiB0aGVcbiAgICogICBnaXZlbiBzZXJ2ZXJDYXBhYmlsaXRpZXMuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGNhbkFkYXB0KHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHNlcnZlckNhcGFiaWxpdGllcy5kb2N1bWVudFN5bWJvbFByb3ZpZGVyID09PSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYzogT2J0YWluIHRoZSBPdXRsaW5lIGZvciBkb2N1bWVudCB2aWEgdGhlIHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb259IGFzIGlkZW50aWZpZWRcbiAgICogYnkgdGhlIHtUZXh0RWRpdG9yfS5cbiAgICpcbiAgICogQHBhcmFtIGNvbm5lY3Rpb24gQSB7TGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9ufSB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRoYXQgd2lsbCBiZSBxdWVyaWVkXG4gICAqICAgZm9yIHRoZSBvdXRsaW5lLlxuICAgKiBAcGFyYW0gZWRpdG9yIFRoZSBBdG9tIHtUZXh0RWRpdG9yfSBjb250YWluaW5nIHRoZSB0ZXh0IHRoZSBPdXRsaW5lIHNob3VsZCByZXByZXNlbnQuXG4gICAqIEByZXR1cm5zIEEge1Byb21pc2V9IGNvbnRhaW5pbmcgdGhlIHtPdXRsaW5lfSBvZiB0aGlzIGRvY3VtZW50LlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGdldE91dGxpbmUoY29ubmVjdGlvbjogTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLCBlZGl0b3I6IFRleHRFZGl0b3IpOiBQcm9taXNlPGF0b21JZGUuT3V0bGluZSB8IG51bGw+IHtcbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgVXRpbHMuZG9XaXRoQ2FuY2VsbGF0aW9uVG9rZW4oY29ubmVjdGlvbiwgdGhpcy5fY2FuY2VsbGF0aW9uVG9rZW5zLCAoY2FuY2VsbGF0aW9uVG9rZW4pID0+XG4gICAgICBjb25uZWN0aW9uLmRvY3VtZW50U3ltYm9sKHsgdGV4dERvY3VtZW50OiBDb252ZXJ0LmVkaXRvclRvVGV4dERvY3VtZW50SWRlbnRpZmllcihlZGl0b3IpIH0sIGNhbmNlbGxhdGlvblRva2VuKSxcbiAgICApO1xuXG4gICAgaWYgKHJlc3VsdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvdXRsaW5lVHJlZXM6IFtdLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoKHJlc3VsdHNbMF0gYXMgRG9jdW1lbnRTeW1ib2wpLnNlbGVjdGlvblJhbmdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIElmIHRoZSBzZXJ2ZXIgaXMgZ2l2aW5nIGJhY2sgdGhlIG5ld2VyIERvY3VtZW50U3ltYm9sIGZvcm1hdC5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG91dGxpbmVUcmVlczogT3V0bGluZVZpZXdBZGFwdGVyLmNyZWF0ZUhpZXJhcmNoaWNhbE91dGxpbmVUcmVlcyhcbiAgICAgICAgICByZXN1bHRzIGFzIERvY3VtZW50U3ltYm9sW10pLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlIHNlcnZlciBpcyBnaXZpbmcgYmFjayB0aGUgb3JpZ2luYWwgU3ltYm9sSW5mb3JtYXRpb24gZm9ybWF0LlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3V0bGluZVRyZWVzOiBPdXRsaW5lVmlld0FkYXB0ZXIuY3JlYXRlT3V0bGluZVRyZWVzKFxuICAgICAgICAgIHJlc3VsdHMgYXMgU3ltYm9sSW5mb3JtYXRpb25bXSksXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWM6IENyZWF0ZSBhbiB7QXJyYXl9IG9mIHtPdXRsaW5lVHJlZX1zIGZyb20gdGhlIEFycmF5IG9mIHtEb2N1bWVudFN5bWJvbH0gcmVjaWV2ZWRcbiAgICogZnJvbSB0aGUgbGFuZ3VhZ2Ugc2VydmVyLiBUaGlzIGluY2x1ZGVzIGNvbnZlcnRpbmcgYWxsIHRoZSBjaGlsZHJlbiBub2RlcyBpbiB0aGUgZW50aXJlXG4gICAqIGhpZXJhcmNoeS5cbiAgICpcbiAgICogQHBhcmFtIHN5bWJvbHMgQW4ge0FycmF5fSBvZiB7RG9jdW1lbnRTeW1ib2x9cyByZWNlaXZlZCBmcm9tIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdGhhdFxuICAgKiAgIHNob3VsZCBiZSBjb252ZXJ0ZWQgdG8gYW4ge0FycmF5fSBvZiB7T3V0bGluZVRyZWV9LlxuICAgKiBAcmV0dXJucyBBbiB7QXJyYXl9IG9mIHtPdXRsaW5lVHJlZX0gY29udGFpbmluZyB0aGUgZ2l2ZW4gc3ltYm9scyB0aGF0IHRoZSBPdXRsaW5lIFZpZXcgY2FuIGRpc3BsYXkuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGNyZWF0ZUhpZXJhcmNoaWNhbE91dGxpbmVUcmVlcyhzeW1ib2xzOiBEb2N1bWVudFN5bWJvbFtdKTogYXRvbUlkZS5PdXRsaW5lVHJlZVtdIHtcbiAgICAvLyBTb3J0IGFsbCB0aGUgaW5jb21pbmcgc3ltYm9sc1xuICAgIHN5bWJvbHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgaWYgKGEucmFuZ2Uuc3RhcnQubGluZSAhPT0gYi5yYW5nZS5zdGFydC5saW5lKSB7XG4gICAgICAgIHJldHVybiBhLnJhbmdlLnN0YXJ0LmxpbmUgLSBiLnJhbmdlLnN0YXJ0LmxpbmU7XG4gICAgICB9XG5cbiAgICAgIGlmIChhLnJhbmdlLnN0YXJ0LmNoYXJhY3RlciAhPT0gYi5yYW5nZS5zdGFydC5jaGFyYWN0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGEucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyIC0gYi5yYW5nZS5zdGFydC5jaGFyYWN0ZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChhLnJhbmdlLmVuZC5saW5lICE9PSBiLnJhbmdlLmVuZC5saW5lKSB7XG4gICAgICAgIHJldHVybiBhLnJhbmdlLmVuZC5saW5lIC0gYi5yYW5nZS5lbmQubGluZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGEucmFuZ2UuZW5kLmNoYXJhY3RlciAtIGIucmFuZ2UuZW5kLmNoYXJhY3RlcjtcbiAgICB9KTtcblxuICAgIHJldHVybiBzeW1ib2xzLm1hcCgoc3ltYm9sKSA9PiB7XG4gICAgICBjb25zdCB0cmVlID0gT3V0bGluZVZpZXdBZGFwdGVyLmhpZXJhcmNoaWNhbFN5bWJvbFRvT3V0bGluZShzeW1ib2wpO1xuXG4gICAgICBpZiAoc3ltYm9sLmNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgICAgdHJlZS5jaGlsZHJlbiA9IE91dGxpbmVWaWV3QWRhcHRlci5jcmVhdGVIaWVyYXJjaGljYWxPdXRsaW5lVHJlZXMoXG4gICAgICAgICAgc3ltYm9sLmNoaWxkcmVuKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRyZWU7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljOiBDcmVhdGUgYW4ge0FycmF5fSBvZiB7T3V0bGluZVRyZWV9cyBmcm9tIHRoZSBBcnJheSBvZiB7U3ltYm9sSW5mb3JtYXRpb259IHJlY2lldmVkXG4gICAqIGZyb20gdGhlIGxhbmd1YWdlIHNlcnZlci4gVGhpcyBpbmNsdWRlcyBkZXRlcm1pbmluZyB0aGUgYXBwcm9wcmlhdGUgY2hpbGQgYW5kIHBhcmVudFxuICAgKiByZWxhdGlvbnNoaXBzIGZvciB0aGUgaGllcmFyY2h5LlxuICAgKlxuICAgKiBAcGFyYW0gc3ltYm9scyBBbiB7QXJyYXl9IG9mIHtTeW1ib2xJbmZvcm1hdGlvbn1zIHJlY2VpdmVkIGZyb20gdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0XG4gICAqICAgc2hvdWxkIGJlIGNvbnZlcnRlZCB0byBhbiB7T3V0bGluZVRyZWV9LlxuICAgKiBAcmV0dXJucyBBbiB7T3V0bGluZVRyZWV9IGNvbnRhaW5pbmcgdGhlIGdpdmVuIHN5bWJvbHMgdGhhdCB0aGUgT3V0bGluZSBWaWV3IGNhbiBkaXNwbGF5LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBjcmVhdGVPdXRsaW5lVHJlZXMoc3ltYm9sczogU3ltYm9sSW5mb3JtYXRpb25bXSk6IGF0b21JZGUuT3V0bGluZVRyZWVbXSB7XG4gICAgc3ltYm9scy5zb3J0KFxuICAgICAgKGEsIGIpID0+XG4gICAgICAgIChhLmxvY2F0aW9uLnJhbmdlLnN0YXJ0LmxpbmUgPT09IGIubG9jYXRpb24ucmFuZ2Uuc3RhcnQubGluZVxuICAgICAgICAgID8gYS5sb2NhdGlvbi5yYW5nZS5zdGFydC5jaGFyYWN0ZXIgLSBiLmxvY2F0aW9uLnJhbmdlLnN0YXJ0LmNoYXJhY3RlclxuICAgICAgICAgIDogYS5sb2NhdGlvbi5yYW5nZS5zdGFydC5saW5lIC0gYi5sb2NhdGlvbi5yYW5nZS5zdGFydC5saW5lKSxcbiAgICApO1xuXG4gICAgLy8gVGVtcG9yYXJpbHkga2VlcCBjb250YWluZXJOYW1lIHRocm91Z2ggdGhlIGNvbnZlcnNpb24gcHJvY2Vzc1xuICAgIC8vIEFsc28gZmlsdGVyIG91dCBzeW1ib2xzIHdpdGhvdXQgYSBuYW1lIC0gaXQncyBwYXJ0IG9mIHRoZSBzcGVjIGJ1dCBzb21lIGRvbid0IGluY2x1ZGUgaXRcbiAgICBjb25zdCBhbGxJdGVtcyA9IHN5bWJvbHMuZmlsdGVyKChzeW1ib2wpID0+IHN5bWJvbC5uYW1lKS5tYXAoKHN5bWJvbCkgPT4gKHtcbiAgICAgIGNvbnRhaW5lck5hbWU6IHN5bWJvbC5jb250YWluZXJOYW1lLFxuICAgICAgb3V0bGluZTogT3V0bGluZVZpZXdBZGFwdGVyLnN5bWJvbFRvT3V0bGluZShzeW1ib2wpLFxuICAgIH0pKTtcblxuICAgIC8vIENyZWF0ZSBhIG1hcCBvZiBjb250YWluZXJzIGJ5IG5hbWUgd2l0aCBhbGwgaXRlbXMgdGhhdCBoYXZlIHRoYXQgbmFtZVxuICAgIGNvbnN0IGNvbnRhaW5lcnMgPSBhbGxJdGVtcy5yZWR1Y2UoKG1hcCwgaXRlbSkgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IGl0ZW0ub3V0bGluZS5yZXByZXNlbnRhdGl2ZU5hbWU7XG4gICAgICBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG1hcC5nZXQobmFtZSk7XG4gICAgICAgIGlmIChjb250YWluZXIgPT0gbnVsbCkge1xuICAgICAgICAgIG1hcC5zZXQobmFtZSwgW2l0ZW0ub3V0bGluZV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRhaW5lci5wdXNoKGl0ZW0ub3V0bGluZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXA7XG4gICAgfSwgbmV3IE1hcCgpKTtcblxuICAgIGNvbnN0IHJvb3RzOiBhdG9tSWRlLk91dGxpbmVUcmVlW10gPSBbXTtcblxuICAgIC8vIFB1dCBlYWNoIGl0ZW0gd2l0aGluIGl0cyBwYXJlbnQgYW5kIGV4dHJhY3Qgb3V0IHRoZSByb290c1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhbGxJdGVtcykge1xuICAgICAgY29uc3QgY29udGFpbmVyTmFtZSA9IGl0ZW0uY29udGFpbmVyTmFtZTtcbiAgICAgIGNvbnN0IGNoaWxkID0gaXRlbS5vdXRsaW5lO1xuICAgICAgaWYgKGNvbnRhaW5lck5hbWUgPT0gbnVsbCB8fCBjb250YWluZXJOYW1lID09PSAnJykge1xuICAgICAgICByb290cy5wdXNoKGl0ZW0ub3V0bGluZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwb3NzaWJsZVBhcmVudHMgPSBjb250YWluZXJzLmdldChjb250YWluZXJOYW1lKTtcbiAgICAgICAgbGV0IGNsb3Nlc3RQYXJlbnQgPSBPdXRsaW5lVmlld0FkYXB0ZXIuX2dldENsb3Nlc3RQYXJlbnQocG9zc2libGVQYXJlbnRzLCBjaGlsZCk7XG4gICAgICAgIGlmIChjbG9zZXN0UGFyZW50ID09IG51bGwpIHtcbiAgICAgICAgICBjbG9zZXN0UGFyZW50ID0ge1xuICAgICAgICAgICAgcGxhaW5UZXh0OiBjb250YWluZXJOYW1lLFxuICAgICAgICAgICAgcmVwcmVzZW50YXRpdmVOYW1lOiBjb250YWluZXJOYW1lLFxuICAgICAgICAgICAgc3RhcnRQb3NpdGlvbjogbmV3IFBvaW50KDAsIDApLFxuICAgICAgICAgICAgY2hpbGRyZW46IFtjaGlsZF0sXG4gICAgICAgICAgfTtcbiAgICAgICAgICByb290cy5wdXNoKGNsb3Nlc3RQYXJlbnQpO1xuICAgICAgICAgIGlmIChwb3NzaWJsZVBhcmVudHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGFpbmVycy5zZXQoY29udGFpbmVyTmFtZSwgW2Nsb3Nlc3RQYXJlbnRdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zc2libGVQYXJlbnRzLnB1c2goY2xvc2VzdFBhcmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsb3Nlc3RQYXJlbnQuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcm9vdHM7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBfZ2V0Q2xvc2VzdFBhcmVudChcbiAgICBjYW5kaWRhdGVzOiBhdG9tSWRlLk91dGxpbmVUcmVlW10gfCBudWxsLFxuICAgIGNoaWxkOiBhdG9tSWRlLk91dGxpbmVUcmVlLFxuICApOiBhdG9tSWRlLk91dGxpbmVUcmVlIHwgbnVsbCB7XG4gICAgaWYgKGNhbmRpZGF0ZXMgPT0gbnVsbCB8fCBjYW5kaWRhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IHBhcmVudDogYXRvbUlkZS5PdXRsaW5lVHJlZSB8IHVuZGVmaW5lZDtcbiAgICBmb3IgKGNvbnN0IGNhbmRpZGF0ZSBvZiBjYW5kaWRhdGVzKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGNhbmRpZGF0ZSAhPT0gY2hpbGQgJiZcbiAgICAgICAgY2FuZGlkYXRlLnN0YXJ0UG9zaXRpb24uaXNMZXNzVGhhbk9yRXF1YWwoY2hpbGQuc3RhcnRQb3NpdGlvbikgJiZcbiAgICAgICAgKGNhbmRpZGF0ZS5lbmRQb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgKGNoaWxkLmVuZFBvc2l0aW9uICYmIGNhbmRpZGF0ZS5lbmRQb3NpdGlvbi5pc0dyZWF0ZXJUaGFuT3JFcXVhbChjaGlsZC5lbmRQb3NpdGlvbikpKVxuICAgICAgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBwYXJlbnQgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgIChwYXJlbnQuc3RhcnRQb3NpdGlvbi5pc0xlc3NUaGFuT3JFcXVhbChjYW5kaWRhdGUuc3RhcnRQb3NpdGlvbikgfHxcbiAgICAgICAgICAgIChwYXJlbnQuZW5kUG9zaXRpb24gIT0gbnVsbCAmJlxuICAgICAgICAgICAgICBjYW5kaWRhdGUuZW5kUG9zaXRpb24gJiZcbiAgICAgICAgICAgICAgcGFyZW50LmVuZFBvc2l0aW9uLmlzR3JlYXRlclRoYW5PckVxdWFsKGNhbmRpZGF0ZS5lbmRQb3NpdGlvbikpKVxuICAgICAgICApIHtcbiAgICAgICAgICBwYXJlbnQgPSBjYW5kaWRhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGFyZW50IHx8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljOiBDb252ZXJ0IGFuIGluZGl2aWR1YWwge0RvY3VtZW50U3ltYm9sfSBmcm9tIHRoZSBsYW5ndWFnZSBzZXJ2ZXJcbiAgICogdG8gYW4ge091dGxpbmVUcmVlfSBmb3IgdXNlIGJ5IHRoZSBPdXRsaW5lIFZpZXcuIEl0IGRvZXMgTk9UIHJlY3Vyc2l2ZWx5XG4gICAqIHByb2Nlc3MgdGhlIGdpdmVuIHN5bWJvbCdzIGNoaWxkcmVuIChpZiBhbnkpLlxuICAgKlxuICAgKiBAcGFyYW0gc3ltYm9sIFRoZSB7RG9jdW1lbnRTeW1ib2x9IHRvIGNvbnZlcnQgdG8gYW4ge091dGxpbmVUcmVlfS5cbiAgICogQHJldHVybnMgVGhlIHtPdXRsaW5lVHJlZX0gY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4ge0RvY3VtZW50U3ltYm9sfS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgaGllcmFyY2hpY2FsU3ltYm9sVG9PdXRsaW5lKHN5bWJvbDogRG9jdW1lbnRTeW1ib2wpOiBhdG9tSWRlLk91dGxpbmVUcmVlIHtcbiAgICBjb25zdCBpY29uID0gT3V0bGluZVZpZXdBZGFwdGVyLnN5bWJvbEtpbmRUb0VudGl0eUtpbmQoc3ltYm9sLmtpbmQpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuaXplZFRleHQ6IFtcbiAgICAgICAge1xuICAgICAgICAgIGtpbmQ6IE91dGxpbmVWaWV3QWRhcHRlci5zeW1ib2xLaW5kVG9Ub2tlbktpbmQoc3ltYm9sLmtpbmQpLFxuICAgICAgICAgIHZhbHVlOiBzeW1ib2wubmFtZSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBpY29uOiBpY29uICE9IG51bGwgPyBpY29uIDogdW5kZWZpbmVkLFxuICAgICAgcmVwcmVzZW50YXRpdmVOYW1lOiBzeW1ib2wubmFtZSxcbiAgICAgIHN0YXJ0UG9zaXRpb246IENvbnZlcnQucG9zaXRpb25Ub1BvaW50KHN5bWJvbC5zZWxlY3Rpb25SYW5nZS5zdGFydCksXG4gICAgICBlbmRQb3NpdGlvbjogQ29udmVydC5wb3NpdGlvblRvUG9pbnQoc3ltYm9sLnNlbGVjdGlvblJhbmdlLmVuZCksXG4gICAgICBjaGlsZHJlbjogW10sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWM6IENvbnZlcnQgYW4gaW5kaXZpZHVhbCB7U3ltYm9sSW5mb3JtYXRpb259IGZyb20gdGhlIGxhbmd1YWdlIHNlcnZlclxuICAgKiB0byBhbiB7T3V0bGluZVRyZWV9IGZvciB1c2UgYnkgdGhlIE91dGxpbmUgVmlldy5cbiAgICpcbiAgICogQHBhcmFtIHN5bWJvbCBUaGUge1N5bWJvbEluZm9ybWF0aW9ufSB0byBjb252ZXJ0IHRvIGFuIHtPdXRsaW5lVHJlZX0uXG4gICAqIEByZXR1cm5zIFRoZSB7T3V0bGluZVRyZWV9IGVxdWl2YWxlbnQgdG8gdGhlIGdpdmVuIHtTeW1ib2xJbmZvcm1hdGlvbn0uXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHN5bWJvbFRvT3V0bGluZShzeW1ib2w6IFN5bWJvbEluZm9ybWF0aW9uKTogYXRvbUlkZS5PdXRsaW5lVHJlZSB7XG4gICAgY29uc3QgaWNvbiA9IE91dGxpbmVWaWV3QWRhcHRlci5zeW1ib2xLaW5kVG9FbnRpdHlLaW5kKHN5bWJvbC5raW5kKTtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW5pemVkVGV4dDogW1xuICAgICAgICB7XG4gICAgICAgICAga2luZDogT3V0bGluZVZpZXdBZGFwdGVyLnN5bWJvbEtpbmRUb1Rva2VuS2luZChzeW1ib2wua2luZCksXG4gICAgICAgICAgdmFsdWU6IHN5bWJvbC5uYW1lLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIGljb246IGljb24gIT0gbnVsbCA/IGljb24gOiB1bmRlZmluZWQsXG4gICAgICByZXByZXNlbnRhdGl2ZU5hbWU6IHN5bWJvbC5uYW1lLFxuICAgICAgc3RhcnRQb3NpdGlvbjogQ29udmVydC5wb3NpdGlvblRvUG9pbnQoc3ltYm9sLmxvY2F0aW9uLnJhbmdlLnN0YXJ0KSxcbiAgICAgIGVuZFBvc2l0aW9uOiBDb252ZXJ0LnBvc2l0aW9uVG9Qb2ludChzeW1ib2wubG9jYXRpb24ucmFuZ2UuZW5kKSxcbiAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYzogQ29udmVydCBhIHN5bWJvbCBraW5kIGludG8gYW4gb3V0bGluZSBlbnRpdHkga2luZCB1c2VkIHRvIGRldGVybWluZVxuICAgKiB0aGUgc3R5bGluZyBzdWNoIGFzIHRoZSBhcHByb3ByaWF0ZSBpY29uIGluIHRoZSBPdXRsaW5lIFZpZXcuXG4gICAqXG4gICAqIEBwYXJhbSBzeW1ib2wgVGhlIG51bWVyaWMgc3ltYm9sIGtpbmQgcmVjZWl2ZWQgZnJvbSB0aGUgbGFuZ3VhZ2Ugc2VydmVyLlxuICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGVxdWl2YWxlbnQgT3V0bGluZVZpZXcgZW50aXR5IGtpbmQuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHN5bWJvbEtpbmRUb0VudGl0eUtpbmQoc3ltYm9sOiBudW1iZXIpOiBzdHJpbmcgfCBudWxsIHtcbiAgICBzd2l0Y2ggKHN5bWJvbCkge1xuICAgICAgY2FzZSBTeW1ib2xLaW5kLkFycmF5OlxuICAgICAgICByZXR1cm4gJ3R5cGUtYXJyYXknO1xuICAgICAgY2FzZSBTeW1ib2xLaW5kLkJvb2xlYW46XG4gICAgICAgIHJldHVybiAndHlwZS1ib29sZWFuJztcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5DbGFzczpcbiAgICAgICAgcmV0dXJuICd0eXBlLWNsYXNzJztcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5Db25zdGFudDpcbiAgICAgICAgcmV0dXJuICd0eXBlLWNvbnN0YW50JztcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5Db25zdHJ1Y3RvcjpcbiAgICAgICAgcmV0dXJuICd0eXBlLWNvbnN0cnVjdG9yJztcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5FbnVtOlxuICAgICAgICByZXR1cm4gJ3R5cGUtZW51bSc7XG4gICAgICBjYXNlIFN5bWJvbEtpbmQuRmllbGQ6XG4gICAgICAgIHJldHVybiAndHlwZS1maWVsZCc7XG4gICAgICBjYXNlIFN5bWJvbEtpbmQuRmlsZTpcbiAgICAgICAgcmV0dXJuICd0eXBlLWZpbGUnO1xuICAgICAgY2FzZSBTeW1ib2xLaW5kLkZ1bmN0aW9uOlxuICAgICAgICByZXR1cm4gJ3R5cGUtZnVuY3Rpb24nO1xuICAgICAgY2FzZSBTeW1ib2xLaW5kLkludGVyZmFjZTpcbiAgICAgICAgcmV0dXJuICd0eXBlLWludGVyZmFjZSc7XG4gICAgICBjYXNlIFN5bWJvbEtpbmQuTWV0aG9kOlxuICAgICAgICByZXR1cm4gJ3R5cGUtbWV0aG9kJztcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5Nb2R1bGU6XG4gICAgICAgIHJldHVybiAndHlwZS1tb2R1bGUnO1xuICAgICAgY2FzZSBTeW1ib2xLaW5kLk5hbWVzcGFjZTpcbiAgICAgICAgcmV0dXJuICd0eXBlLW5hbWVzcGFjZSc7XG4gICAgICBjYXNlIFN5bWJvbEtpbmQuTnVtYmVyOlxuICAgICAgICByZXR1cm4gJ3R5cGUtbnVtYmVyJztcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5QYWNrYWdlOlxuICAgICAgICByZXR1cm4gJ3R5cGUtcGFja2FnZSc7XG4gICAgICBjYXNlIFN5bWJvbEtpbmQuUHJvcGVydHk6XG4gICAgICAgIHJldHVybiAndHlwZS1wcm9wZXJ0eSc7XG4gICAgICBjYXNlIFN5bWJvbEtpbmQuU3RyaW5nOlxuICAgICAgICByZXR1cm4gJ3R5cGUtc3RyaW5nJztcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5WYXJpYWJsZTpcbiAgICAgICAgcmV0dXJuICd0eXBlLXZhcmlhYmxlJztcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5TdHJ1Y3Q6XG4gICAgICAgIHJldHVybiAndHlwZS1jbGFzcyc7XG4gICAgICBjYXNlIFN5bWJvbEtpbmQuRW51bU1lbWJlcjpcbiAgICAgICAgcmV0dXJuICd0eXBlLWNvbnN0YW50JztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWM6IENvbnZlcnQgYSBzeW1ib2wga2luZCB0byB0aGUgYXBwcm9wcmlhdGUgdG9rZW4ga2luZCB1c2VkIHRvIHN5bnRheFxuICAgKiBoaWdobGlnaHQgdGhlIHN5bWJvbCBuYW1lIGluIHRoZSBPdXRsaW5lIFZpZXcuXG4gICAqXG4gICAqIEBwYXJhbSBzeW1ib2wgVGhlIG51bWVyaWMgc3ltYm9sIGtpbmQgcmVjZWl2ZWQgZnJvbSB0aGUgbGFuZ3VhZ2Ugc2VydmVyLlxuICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGVxdWl2YWxlbnQgc3ludGF4IHRva2VuIGtpbmQuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHN5bWJvbEtpbmRUb1Rva2VuS2luZChzeW1ib2w6IG51bWJlcik6IGF0b21JZGUuVG9rZW5LaW5kIHtcbiAgICBzd2l0Y2ggKHN5bWJvbCkge1xuICAgICAgY2FzZSBTeW1ib2xLaW5kLkNsYXNzOlxuICAgICAgICByZXR1cm4gJ3R5cGUnO1xuICAgICAgY2FzZSBTeW1ib2xLaW5kLkNvbnN0cnVjdG9yOlxuICAgICAgICByZXR1cm4gJ2NvbnN0cnVjdG9yJztcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5NZXRob2Q6XG4gICAgICBjYXNlIFN5bWJvbEtpbmQuRnVuY3Rpb246XG4gICAgICAgIHJldHVybiAnbWV0aG9kJztcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5TdHJpbmc6XG4gICAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAncGxhaW4nO1xuICAgIH1cbiAgfVxufVxuIl19