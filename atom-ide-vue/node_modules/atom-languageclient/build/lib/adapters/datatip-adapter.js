"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const convert_1 = require("../convert");
const Utils = require("../utils");
/**
 * Public: Adapts the language server protocol "textDocument/hover" to the
 * Atom IDE UI Datatip package.
 */
class DatatipAdapter {
    /**
     * Public: Determine whether this adapter can be used to adapt a language server
     * based on the serverCapabilities matrix containing a hoverProvider.
     *
     * @param serverCapabilities The {ServerCapabilities} of the language server to consider.
     * @returns A {Boolean} indicating adapter can adapt the server based on the
     *   given serverCapabilities.
     */
    static canAdapt(serverCapabilities) {
        return serverCapabilities.hoverProvider === true;
    }
    /**
     * Public: Get the Datatip for this {Point} in a {TextEditor} by querying
     * the language server.
     *
     * @param connection A {LanguageClientConnection} to the language server that will be queried
     *   for the hover text/datatip.
     * @param editor The Atom {TextEditor} containing the text the Datatip should relate to.
     * @param point The Atom {Point} containing the point within the text the Datatip should relate to.
     * @returns A {Promise} containing the {Datatip} to display or {null} if no Datatip is available.
     */
    getDatatip(connection, editor, point) {
        return __awaiter(this, void 0, void 0, function* () {
            const documentPositionParams = convert_1.default.editorToTextDocumentPositionParams(editor, point);
            const hover = yield connection.hover(documentPositionParams);
            if (hover == null || DatatipAdapter.isEmptyHover(hover)) {
                return null;
            }
            const range = hover.range == null ? Utils.getWordAtPosition(editor, point) : convert_1.default.lsRangeToAtomRange(hover.range);
            const markedStrings = (Array.isArray(hover.contents) ? hover.contents : [hover.contents]).map((str) => DatatipAdapter.convertMarkedString(editor, str));
            return { range, markedStrings };
        });
    }
    static isEmptyHover(hover) {
        return hover.contents == null ||
            (typeof hover.contents === 'string' && hover.contents.length === 0) ||
            (Array.isArray(hover.contents) &&
                (hover.contents.length === 0 || hover.contents[0] === ""));
    }
    static convertMarkedString(editor, markedString) {
        if (typeof markedString === 'string') {
            return { type: 'markdown', value: markedString };
        }
        if (markedString.kind) {
            return {
                type: 'markdown',
                value: markedString.value,
            };
        }
        // Must check as <{language: string}> to disambiguate between
        // string and the more explicit object type because MarkedString
        // is a union of the two types
        if (markedString.language) {
            return {
                type: 'snippet',
                // TODO: find a better mapping from language -> grammar
                grammar: atom.grammars.grammarForScopeName(`source.${markedString.language}`) || editor.getGrammar(),
                value: markedString.value,
            };
        }
        // Catch-all case
        return { type: 'markdown', value: markedString.toString() };
    }
}
exports.default = DatatipAdapter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YXRpcC1hZGFwdGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbGliL2FkYXB0ZXJzL2RhdGF0aXAtYWRhcHRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUNBLHdDQUFpQztBQUNqQyxrQ0FBa0M7QUFhbEM7OztHQUdHO0FBQ0gsTUFBcUIsY0FBYztJQUNqQzs7Ozs7OztPQU9HO0lBQ0ksTUFBTSxDQUFDLFFBQVEsQ0FBQyxrQkFBc0M7UUFDM0QsT0FBTyxrQkFBa0IsQ0FBQyxhQUFhLEtBQUssSUFBSSxDQUFDO0lBQ25ELENBQUM7SUFFRDs7Ozs7Ozs7O09BU0c7SUFDVSxVQUFVLENBQ3JCLFVBQW9DLEVBQ3BDLE1BQWtCLEVBQ2xCLEtBQVk7O1lBRVosTUFBTSxzQkFBc0IsR0FBRyxpQkFBTyxDQUFDLGtDQUFrQyxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztZQUV6RixNQUFNLEtBQUssR0FBRyxNQUFNLFVBQVUsQ0FBQyxLQUFLLENBQUMsc0JBQXNCLENBQUMsQ0FBQztZQUM3RCxJQUFJLEtBQUssSUFBSSxJQUFJLElBQUksY0FBYyxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsRUFBRTtnQkFDdkQsT0FBTyxJQUFJLENBQUM7YUFDYjtZQUVELE1BQU0sS0FBSyxHQUNULEtBQUssQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsaUJBQWlCLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxpQkFBTyxDQUFDLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUV6RyxNQUFNLGFBQWEsR0FBRyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQ3BHLGNBQWMsQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQ2hELENBQUM7WUFFRixPQUFPLEVBQUUsS0FBSyxFQUFFLGFBQWEsRUFBRSxDQUFDO1FBQ2xDLENBQUM7S0FBQTtJQUVPLE1BQU0sQ0FBQyxZQUFZLENBQUMsS0FBWTtRQUN0QyxPQUFPLEtBQUssQ0FBQyxRQUFRLElBQUksSUFBSTtZQUMzQixDQUFDLE9BQU8sS0FBSyxDQUFDLFFBQVEsS0FBSyxRQUFRLElBQUksS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDO1lBQ25FLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDO2dCQUM1QixDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsTUFBTSxLQUFLLENBQUMsSUFBSSxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDakUsQ0FBQztJQUVPLE1BQU0sQ0FBQyxtQkFBbUIsQ0FDaEMsTUFBa0IsRUFDbEIsWUFBMEM7UUFFMUMsSUFBSSxPQUFPLFlBQVksS0FBSyxRQUFRLEVBQUU7WUFDcEMsT0FBTyxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFLFlBQVksRUFBRSxDQUFDO1NBQ2xEO1FBRUQsSUFBSyxZQUE4QixDQUFDLElBQUksRUFBRTtZQUN4QyxPQUFPO2dCQUNMLElBQUksRUFBRSxVQUFVO2dCQUNoQixLQUFLLEVBQUUsWUFBWSxDQUFDLEtBQUs7YUFDMUIsQ0FBQztTQUNIO1FBRUQsNkRBQTZEO1FBQzdELGdFQUFnRTtRQUNoRSw4QkFBOEI7UUFDOUIsSUFBSyxZQUFxQyxDQUFDLFFBQVEsRUFBRTtZQUNuRCxPQUFPO2dCQUNMLElBQUksRUFBRSxTQUFTO2dCQUNmLHVEQUF1RDtnQkFDdkQsT0FBTyxFQUNMLElBQUksQ0FBQyxRQUFRLENBQUMsbUJBQW1CLENBQy9CLFVBQVcsWUFBcUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxVQUFVLEVBQUU7Z0JBQ3ZGLEtBQUssRUFBRSxZQUFZLENBQUMsS0FBSzthQUMxQixDQUFDO1NBQ0g7UUFFRCxpQkFBaUI7UUFDakIsT0FBTyxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFLFlBQVksQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDO0lBQzlELENBQUM7Q0FDRjtBQXBGRCxpQ0FvRkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBhdG9tSWRlIGZyb20gJ2F0b20taWRlJztcbmltcG9ydCBDb252ZXJ0IGZyb20gJy4uL2NvbnZlcnQnO1xuaW1wb3J0ICogYXMgVXRpbHMgZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHtcbiAgSG92ZXIsXG4gIExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcbiAgTWFya3VwQ29udGVudCxcbiAgTWFya2VkU3RyaW5nLFxuICBTZXJ2ZXJDYXBhYmlsaXRpZXMsXG59IGZyb20gJy4uL2xhbmd1YWdlY2xpZW50JztcbmltcG9ydCB7XG4gIFBvaW50LFxuICBUZXh0RWRpdG9yLFxufSBmcm9tICdhdG9tJztcblxuLyoqXG4gKiBQdWJsaWM6IEFkYXB0cyB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHByb3RvY29sIFwidGV4dERvY3VtZW50L2hvdmVyXCIgdG8gdGhlXG4gKiBBdG9tIElERSBVSSBEYXRhdGlwIHBhY2thZ2UuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERhdGF0aXBBZGFwdGVyIHtcbiAgLyoqXG4gICAqIFB1YmxpYzogRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBhZGFwdGVyIGNhbiBiZSB1c2VkIHRvIGFkYXB0IGEgbGFuZ3VhZ2Ugc2VydmVyXG4gICAqIGJhc2VkIG9uIHRoZSBzZXJ2ZXJDYXBhYmlsaXRpZXMgbWF0cml4IGNvbnRhaW5pbmcgYSBob3ZlclByb3ZpZGVyLlxuICAgKlxuICAgKiBAcGFyYW0gc2VydmVyQ2FwYWJpbGl0aWVzIFRoZSB7U2VydmVyQ2FwYWJpbGl0aWVzfSBvZiB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRvIGNvbnNpZGVyLlxuICAgKiBAcmV0dXJucyBBIHtCb29sZWFufSBpbmRpY2F0aW5nIGFkYXB0ZXIgY2FuIGFkYXB0IHRoZSBzZXJ2ZXIgYmFzZWQgb24gdGhlXG4gICAqICAgZ2l2ZW4gc2VydmVyQ2FwYWJpbGl0aWVzLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBjYW5BZGFwdChzZXJ2ZXJDYXBhYmlsaXRpZXM6IFNlcnZlckNhcGFiaWxpdGllcyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBzZXJ2ZXJDYXBhYmlsaXRpZXMuaG92ZXJQcm92aWRlciA9PT0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWM6IEdldCB0aGUgRGF0YXRpcCBmb3IgdGhpcyB7UG9pbnR9IGluIGEge1RleHRFZGl0b3J9IGJ5IHF1ZXJ5aW5nXG4gICAqIHRoZSBsYW5ndWFnZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEBwYXJhbSBjb25uZWN0aW9uIEEge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbn0gdG8gdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0IHdpbGwgYmUgcXVlcmllZFxuICAgKiAgIGZvciB0aGUgaG92ZXIgdGV4dC9kYXRhdGlwLlxuICAgKiBAcGFyYW0gZWRpdG9yIFRoZSBBdG9tIHtUZXh0RWRpdG9yfSBjb250YWluaW5nIHRoZSB0ZXh0IHRoZSBEYXRhdGlwIHNob3VsZCByZWxhdGUgdG8uXG4gICAqIEBwYXJhbSBwb2ludCBUaGUgQXRvbSB7UG9pbnR9IGNvbnRhaW5pbmcgdGhlIHBvaW50IHdpdGhpbiB0aGUgdGV4dCB0aGUgRGF0YXRpcCBzaG91bGQgcmVsYXRlIHRvLlxuICAgKiBAcmV0dXJucyBBIHtQcm9taXNlfSBjb250YWluaW5nIHRoZSB7RGF0YXRpcH0gdG8gZGlzcGxheSBvciB7bnVsbH0gaWYgbm8gRGF0YXRpcCBpcyBhdmFpbGFibGUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZ2V0RGF0YXRpcChcbiAgICBjb25uZWN0aW9uOiBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXG4gICAgZWRpdG9yOiBUZXh0RWRpdG9yLFxuICAgIHBvaW50OiBQb2ludCxcbiAgKTogUHJvbWlzZTxhdG9tSWRlLkRhdGF0aXAgfCBudWxsPiB7XG4gICAgY29uc3QgZG9jdW1lbnRQb3NpdGlvblBhcmFtcyA9IENvbnZlcnQuZWRpdG9yVG9UZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtcyhlZGl0b3IsIHBvaW50KTtcblxuICAgIGNvbnN0IGhvdmVyID0gYXdhaXQgY29ubmVjdGlvbi5ob3Zlcihkb2N1bWVudFBvc2l0aW9uUGFyYW1zKTtcbiAgICBpZiAoaG92ZXIgPT0gbnVsbCB8fCBEYXRhdGlwQWRhcHRlci5pc0VtcHR5SG92ZXIoaG92ZXIpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCByYW5nZSA9XG4gICAgICBob3Zlci5yYW5nZSA9PSBudWxsID8gVXRpbHMuZ2V0V29yZEF0UG9zaXRpb24oZWRpdG9yLCBwb2ludCkgOiBDb252ZXJ0LmxzUmFuZ2VUb0F0b21SYW5nZShob3Zlci5yYW5nZSk7XG5cbiAgICBjb25zdCBtYXJrZWRTdHJpbmdzID0gKEFycmF5LmlzQXJyYXkoaG92ZXIuY29udGVudHMpID8gaG92ZXIuY29udGVudHMgOiBbaG92ZXIuY29udGVudHNdKS5tYXAoKHN0cikgPT5cbiAgICAgIERhdGF0aXBBZGFwdGVyLmNvbnZlcnRNYXJrZWRTdHJpbmcoZWRpdG9yLCBzdHIpLFxuICAgICk7XG5cbiAgICByZXR1cm4geyByYW5nZSwgbWFya2VkU3RyaW5ncyB9O1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgaXNFbXB0eUhvdmVyKGhvdmVyOiBIb3Zlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBob3Zlci5jb250ZW50cyA9PSBudWxsIHx8XG4gICAgICAodHlwZW9mIGhvdmVyLmNvbnRlbnRzID09PSAnc3RyaW5nJyAmJiBob3Zlci5jb250ZW50cy5sZW5ndGggPT09IDApIHx8XG4gICAgICAoQXJyYXkuaXNBcnJheShob3Zlci5jb250ZW50cykgJiZcbiAgICAgICAgKGhvdmVyLmNvbnRlbnRzLmxlbmd0aCA9PT0gMCB8fCBob3Zlci5jb250ZW50c1swXSA9PT0gXCJcIikpO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgY29udmVydE1hcmtlZFN0cmluZyhcbiAgICBlZGl0b3I6IFRleHRFZGl0b3IsXG4gICAgbWFya2VkU3RyaW5nOiBNYXJrZWRTdHJpbmcgfCBNYXJrdXBDb250ZW50LFxuICApOiBhdG9tSWRlLk1hcmtlZFN0cmluZyB7XG4gICAgaWYgKHR5cGVvZiBtYXJrZWRTdHJpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiAnbWFya2Rvd24nLCB2YWx1ZTogbWFya2VkU3RyaW5nIH07XG4gICAgfVxuXG4gICAgaWYgKChtYXJrZWRTdHJpbmcgYXMgTWFya3VwQ29udGVudCkua2luZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ21hcmtkb3duJyxcbiAgICAgICAgdmFsdWU6IG1hcmtlZFN0cmluZy52YWx1ZSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gTXVzdCBjaGVjayBhcyA8e2xhbmd1YWdlOiBzdHJpbmd9PiB0byBkaXNhbWJpZ3VhdGUgYmV0d2VlblxuICAgIC8vIHN0cmluZyBhbmQgdGhlIG1vcmUgZXhwbGljaXQgb2JqZWN0IHR5cGUgYmVjYXVzZSBNYXJrZWRTdHJpbmdcbiAgICAvLyBpcyBhIHVuaW9uIG9mIHRoZSB0d28gdHlwZXNcbiAgICBpZiAoKG1hcmtlZFN0cmluZyBhcyB7IGxhbmd1YWdlOiBzdHJpbmcgfSkubGFuZ3VhZ2UpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdzbmlwcGV0JyxcbiAgICAgICAgLy8gVE9ETzogZmluZCBhIGJldHRlciBtYXBwaW5nIGZyb20gbGFuZ3VhZ2UgLT4gZ3JhbW1hclxuICAgICAgICBncmFtbWFyOlxuICAgICAgICAgIGF0b20uZ3JhbW1hcnMuZ3JhbW1hckZvclNjb3BlTmFtZShcbiAgICAgICAgICAgIGBzb3VyY2UuJHsobWFya2VkU3RyaW5nIGFzIHsgbGFuZ3VhZ2U6IHN0cmluZyB9KS5sYW5ndWFnZX1gKSB8fCBlZGl0b3IuZ2V0R3JhbW1hcigpLFxuICAgICAgICB2YWx1ZTogbWFya2VkU3RyaW5nLnZhbHVlLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBDYXRjaC1hbGwgY2FzZVxuICAgIHJldHVybiB7IHR5cGU6ICdtYXJrZG93bicsIHZhbHVlOiBtYXJrZWRTdHJpbmcudG9TdHJpbmcoKSB9O1xuICB9XG59XG4iXX0=