"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const convert_1 = require("../convert");
const Utils = require("../utils");
const fuzzaldrin_plus_1 = require("fuzzaldrin-plus");
const languageclient_1 = require("../languageclient");
const atom_1 = require("atom");
class PossiblyResolvedCompletionItem {
    constructor(completionItem, isResolved) {
        this.completionItem = completionItem;
        this.isResolved = isResolved;
    }
}
/**
 * Public: Adapts the language server protocol "textDocument/completion" to the Atom
 * AutoComplete+ package.
 */
class AutocompleteAdapter {
    constructor() {
        this._suggestionCache = new WeakMap();
        this._cancellationTokens = new WeakMap();
    }
    static canAdapt(serverCapabilities) {
        return serverCapabilities.completionProvider != null;
    }
    static canResolve(serverCapabilities) {
        return serverCapabilities.completionProvider != null &&
            serverCapabilities.completionProvider.resolveProvider === true;
    }
    /**
     * Public: Obtain suggestion list for AutoComplete+ by querying the language server using
     * the `textDocument/completion` request.
     *
     * @param server An {ActiveServer} pointing to the language server to query.
     * @param request The {atom$AutocompleteRequest} to satisfy.
     * @param onDidConvertCompletionItem An optional function that takes a {CompletionItem},
     *   an {atom$AutocompleteSuggestion} and a {atom$AutocompleteRequest}
     *   allowing you to adjust converted items.
     * @returns A {Promise} of an {Array} of {atom$AutocompleteSuggestion}s containing the
     *   AutoComplete+ suggestions to display.
     */
    getSuggestions(server, request, onDidConvertCompletionItem, minimumWordLength) {
        return __awaiter(this, void 0, void 0, function* () {
            const triggerChars = server.capabilities.completionProvider != null
                ? server.capabilities.completionProvider.triggerCharacters || []
                : [];
            // triggerOnly is true if we have just typed in a trigger character, and is false if we
            // have typed additional characters following a trigger character.
            const [triggerChar, triggerOnly] = AutocompleteAdapter.getTriggerCharacter(request, triggerChars);
            if (!this.shouldTrigger(request, triggerChar, minimumWordLength || 0)) {
                return [];
            }
            // Get the suggestions either from the cache or by calling the language server
            const suggestions = yield this.getOrBuildSuggestions(server, request, triggerChar, triggerOnly, onDidConvertCompletionItem);
            // We must update the replacement prefix as characters are added and removed
            const cache = this._suggestionCache.get(server);
            const replacementPrefix = request.editor.getTextInBufferRange([cache.triggerPoint, request.bufferPosition]);
            for (const suggestion of suggestions) {
                if (suggestion.customReplacmentPrefix) { // having this property means a custom range was provided
                    const len = replacementPrefix.length;
                    const preReplacementPrefix = suggestion.customReplacmentPrefix
                        + replacementPrefix.substring(len + cache.originalBufferPoint.column - request.bufferPosition.column, len);
                    // we cannot replace text after the cursor with the current autocomplete-plus API
                    // so we will simply ignore it for now
                    suggestion.replacementPrefix = preReplacementPrefix;
                }
                else {
                    suggestion.replacementPrefix = replacementPrefix;
                }
            }
            const filtered = !(request.prefix === "" || (triggerChar !== '' && triggerOnly));
            return filtered ? fuzzaldrin_plus_1.filter(suggestions, request.prefix, { key: 'filterText' }) : suggestions;
        });
    }
    shouldTrigger(request, triggerChar, minWordLength) {
        return request.activatedManually
            || triggerChar !== ''
            || minWordLength <= 0
            || request.prefix.length >= minWordLength;
    }
    getOrBuildSuggestions(server, request, triggerChar, triggerOnly, onDidConvertCompletionItem) {
        return __awaiter(this, void 0, void 0, function* () {
            const cache = this._suggestionCache.get(server);
            const triggerColumn = (triggerChar !== '' && triggerOnly)
                ? request.bufferPosition.column - triggerChar.length
                : request.bufferPosition.column - request.prefix.length - triggerChar.length;
            const triggerPoint = new atom_1.Point(request.bufferPosition.row, triggerColumn);
            // Do we have complete cached suggestions that are still valid for this request?
            if (cache && !cache.isIncomplete && cache.triggerChar === triggerChar
                && cache.triggerPoint.isEqual(triggerPoint)
                && cache.originalBufferPoint.isLessThanOrEqual(request.bufferPosition)) {
                return Array.from(cache.suggestionMap.keys());
            }
            // Our cached suggestions can't be used so obtain new ones from the language server
            const completions = yield Utils.doWithCancellationToken(server.connection, this._cancellationTokens, (cancellationToken) => server.connection.completion(AutocompleteAdapter.createCompletionParams(request, triggerChar, triggerOnly), cancellationToken));
            // spec guarantees all edits are on the same line, so we only need to check the columns
            const triggerColumns = [triggerPoint.column, request.bufferPosition.column];
            // Setup the cache for subsequent filtered results
            const isComplete = completions === null || Array.isArray(completions) || completions.isIncomplete === false;
            const suggestionMap = this.completionItemsToSuggestions(completions, request, triggerColumns, onDidConvertCompletionItem);
            this._suggestionCache.set(server, {
                isIncomplete: !isComplete,
                triggerChar,
                triggerPoint,
                originalBufferPoint: request.bufferPosition,
                suggestionMap,
            });
            return Array.from(suggestionMap.keys());
        });
    }
    /**
     * Public: Obtain a complete version of a suggestion with additional information
     * the language server can provide by way of the `completionItem/resolve` request.
     *
     * @param server An {ActiveServer} pointing to the language server to query.
     * @param suggestion An {atom$AutocompleteSuggestion} suggestion that should be resolved.
     * @param request An {Object} with the AutoComplete+ request to satisfy.
     * @param onDidConvertCompletionItem An optional function that takes a {CompletionItem}, an
     *   {atom$AutocompleteSuggestion} and a {atom$AutocompleteRequest} allowing you to adjust converted items.
     * @returns A {Promise} of an {atom$AutocompleteSuggestion} with the resolved AutoComplete+ suggestion.
     */
    completeSuggestion(server, suggestion, request, onDidConvertCompletionItem) {
        return __awaiter(this, void 0, void 0, function* () {
            const cache = this._suggestionCache.get(server);
            if (cache) {
                const possiblyResolvedCompletionItem = cache.suggestionMap.get(suggestion);
                if (possiblyResolvedCompletionItem != null && possiblyResolvedCompletionItem.isResolved === false) {
                    const resolvedCompletionItem = yield server.connection.completionItemResolve(possiblyResolvedCompletionItem.completionItem);
                    if (resolvedCompletionItem != null) {
                        AutocompleteAdapter.resolveSuggestion(resolvedCompletionItem, suggestion, request, onDidConvertCompletionItem);
                        possiblyResolvedCompletionItem.isResolved = true;
                    }
                }
            }
            return suggestion;
        });
    }
    static resolveSuggestion(resolvedCompletionItem, suggestion, request, onDidConvertCompletionItem) {
        // only the `documentation` and `detail` properties may change when resolving
        AutocompleteAdapter.applyDetailsToSuggestion(resolvedCompletionItem, suggestion);
        if (onDidConvertCompletionItem != null) {
            onDidConvertCompletionItem(resolvedCompletionItem, suggestion, request);
        }
    }
    /**
     * Public: Get the trigger character that caused the autocomplete (if any).  This is required because
     * AutoComplete-plus does not have trigger characters.  Although the terminology is 'character' we treat
     * them as variable length strings as this will almost certainly change in the future to support '->' etc.
     *
     * @param request An {Array} of {atom$AutocompleteSuggestion}s to locate the prefix, editor, bufferPosition etc.
     * @param triggerChars The {Array} of {string}s that can be trigger characters.
     * @returns A [{string}, boolean] where the string is the matching trigger character or an empty string
     *   if one was not matched, and the boolean is true if the trigger character is in request.prefix, and false
     *   if it is in the word before request.prefix. The boolean return value has no meaning if the string return
     *   value is an empty string.
     */
    static getTriggerCharacter(request, triggerChars) {
        // AutoComplete-Plus considers text after a symbol to be a new trigger. So we should look backward
        // from the current cursor position to see if one is there and thus simulate it.
        const buffer = request.editor.getBuffer();
        const cursor = request.bufferPosition;
        const prefixStartColumn = cursor.column - request.prefix.length;
        for (const triggerChar of triggerChars) {
            if (request.prefix.endsWith(triggerChar)) {
                return [triggerChar, true];
            }
            if (prefixStartColumn >= triggerChar.length) { // Far enough along a line to fit the trigger char
                const start = new atom_1.Point(cursor.row, prefixStartColumn - triggerChar.length);
                const possibleTrigger = buffer.getTextInRange([start, [cursor.row, prefixStartColumn]]);
                if (possibleTrigger === triggerChar) { // The text before our trigger is a trigger char!
                    return [triggerChar, false];
                }
            }
        }
        // There was no explicit trigger char
        return ['', false];
    }
    /**
     * Public: Create TextDocumentPositionParams to be sent to the language server
     * based on the editor and position from the AutoCompleteRequest.
     *
     * @param request The {atom$AutocompleteRequest} to obtain the editor from.
     * @param triggerPoint The {atom$Point} where the trigger started.
     * @returns A {string} containing the prefix including the trigger character.
     */
    static getPrefixWithTrigger(request, triggerPoint) {
        return request.editor
            .getBuffer()
            .getTextInRange([[triggerPoint.row, triggerPoint.column], request.bufferPosition]);
    }
    /**
     * Public: Create {CompletionParams} to be sent to the language server
     * based on the editor and position from the Autocomplete request etc.
     *
     * @param request The {atom$AutocompleteRequest} containing the request details.
     * @param triggerCharacter The {string} containing the trigger character (empty if none).
     * @param triggerOnly A {boolean} representing whether this completion is triggered right after a trigger character.
     * @returns A {CompletionParams} with the keys:
     *   * `textDocument` the language server protocol textDocument identification.
     *   * `position` the position within the text document to display completion request for.
     *   * `context` containing the trigger character and kind.
     */
    static createCompletionParams(request, triggerCharacter, triggerOnly) {
        return {
            textDocument: convert_1.default.editorToTextDocumentIdentifier(request.editor),
            position: convert_1.default.pointToPosition(request.bufferPosition),
            context: AutocompleteAdapter.createCompletionContext(triggerCharacter, triggerOnly),
        };
    }
    /**
     * Public: Create {CompletionContext} to be sent to the language server
     * based on the trigger character.
     *
     * @param triggerCharacter The {string} containing the trigger character or '' if none.
     * @param triggerOnly A {boolean} representing whether this completion is triggered right after a trigger character.
     * @returns An {CompletionContext} that specifies the triggerKind and the triggerCharacter
     *   if there is one.
     */
    static createCompletionContext(triggerCharacter, triggerOnly) {
        if (triggerCharacter === '') {
            return { triggerKind: languageclient_1.CompletionTriggerKind.Invoked };
        }
        else {
            return triggerOnly
                ? { triggerKind: languageclient_1.CompletionTriggerKind.TriggerCharacter, triggerCharacter }
                : { triggerKind: languageclient_1.CompletionTriggerKind.TriggerForIncompleteCompletions, triggerCharacter };
        }
    }
    /**
     * Public: Convert a language server protocol CompletionItem array or CompletionList to
     * an array of ordered AutoComplete+ suggestions.
     *
     * @param completionItems An {Array} of {CompletionItem} objects or a {CompletionList} containing completion
     *   items to be converted.
     * @param request The {atom$AutocompleteRequest} to satisfy.
     * @param onDidConvertCompletionItem A function that takes a {CompletionItem}, an {atom$AutocompleteSuggestion}
     *   and a {atom$AutocompleteRequest} allowing you to adjust converted items.
     * @returns A {Map} of AutoComplete+ suggestions ordered by the CompletionItems sortText.
     */
    completionItemsToSuggestions(completionItems, request, triggerColumns, onDidConvertCompletionItem) {
        const completionsArray = Array.isArray(completionItems)
            ? completionItems
            : (completionItems && completionItems.items) || [];
        return new Map(completionsArray
            .sort((a, b) => (a.sortText || a.label).localeCompare(b.sortText || b.label))
            .map((s) => [
            AutocompleteAdapter.completionItemToSuggestion(s, {}, request, triggerColumns, onDidConvertCompletionItem),
            new PossiblyResolvedCompletionItem(s, false),
        ]));
    }
    /**
     * Public: Convert a language server protocol CompletionItem to an AutoComplete+ suggestion.
     *
     * @param item An {CompletionItem} containing a completion item to be converted.
     * @param suggestion A {atom$AutocompleteSuggestion} to have the conversion applied to.
     * @param request The {atom$AutocompleteRequest} to satisfy.
     * @param onDidConvertCompletionItem A function that takes a {CompletionItem}, an {atom$AutocompleteSuggestion}
     *   and a {atom$AutocompleteRequest} allowing you to adjust converted items.
     * @returns The {atom$AutocompleteSuggestion} passed in as suggestion with the conversion applied.
     */
    static completionItemToSuggestion(item, suggestion, request, triggerColumns, onDidConvertCompletionItem) {
        AutocompleteAdapter.applyCompletionItemToSuggestion(item, suggestion);
        AutocompleteAdapter.applyTextEditToSuggestion(item.textEdit, request.editor, triggerColumns, request.bufferPosition, suggestion);
        AutocompleteAdapter.applySnippetToSuggestion(item, suggestion);
        if (onDidConvertCompletionItem != null) {
            onDidConvertCompletionItem(item, suggestion, request);
        }
        return suggestion;
    }
    /**
     * Public: Convert the primary parts of a language server protocol CompletionItem to an AutoComplete+ suggestion.
     *
     * @param item An {CompletionItem} containing the completion items to be merged into.
     * @param suggestion The {Suggestion} to merge the conversion into.
     * @returns The {Suggestion} with details added from the {CompletionItem}.
     */
    static applyCompletionItemToSuggestion(item, suggestion) {
        suggestion.text = item.insertText || item.label;
        suggestion.filterText = item.filterText || item.label;
        suggestion.displayText = item.label;
        suggestion.type = AutocompleteAdapter.completionKindToSuggestionType(item.kind);
        AutocompleteAdapter.applyDetailsToSuggestion(item, suggestion);
    }
    static applyDetailsToSuggestion(item, suggestion) {
        suggestion.rightLabel = item.detail;
        // Older format, can't know what it is so assign to both and hope for best
        if (typeof (item.documentation) === 'string') {
            suggestion.descriptionMarkdown = item.documentation;
            suggestion.description = item.documentation;
        }
        if (item.documentation != null && typeof (item.documentation) === 'object') {
            // Newer format specifies the kind of documentation, assign appropriately
            if (item.documentation.kind === 'markdown') {
                suggestion.descriptionMarkdown = item.documentation.value;
            }
            else {
                suggestion.description = item.documentation.value;
            }
        }
    }
    /**
     * Public: Applies the textEdit part of a language server protocol CompletionItem to an
     * AutoComplete+ Suggestion via the replacementPrefix and text properties.
     *
     * @param textEdit A {TextEdit} from a CompletionItem to apply.
     * @param editor An Atom {TextEditor} used to obtain the necessary text replacement.
     * @param suggestion An {atom$AutocompleteSuggestion} to set the replacementPrefix and text properties of.
     */
    static applyTextEditToSuggestion(textEdit, editor, triggerColumns, originalBufferPosition, suggestion) {
        if (!textEdit) {
            return;
        }
        if (textEdit.range.start.character !== triggerColumns[0]) {
            const range = convert_1.default.lsRangeToAtomRange(textEdit.range);
            suggestion.customReplacmentPrefix = editor.getTextInBufferRange([range.start, originalBufferPosition]);
        }
        suggestion.text = textEdit.newText;
    }
    /**
     * Public: Adds a snippet to the suggestion if the CompletionItem contains
     * snippet-formatted text
     *
     * @param item An {CompletionItem} containing the completion items to be merged into.
     * @param suggestion The {atom$AutocompleteSuggestion} to merge the conversion into.
     */
    static applySnippetToSuggestion(item, suggestion) {
        if (item.insertTextFormat === languageclient_1.InsertTextFormat.Snippet) {
            suggestion.snippet = item.textEdit != null ? item.textEdit.newText : (item.insertText || '');
        }
    }
    /**
     * Public: Obtain the textual suggestion type required by AutoComplete+ that
     * most closely maps to the numeric completion kind supplies by the language server.
     *
     * @param kind A {Number} that represents the suggestion kind to be converted.
     * @returns A {String} containing the AutoComplete+ suggestion type equivalent
     *   to the given completion kind.
     */
    static completionKindToSuggestionType(kind) {
        switch (kind) {
            case languageclient_1.CompletionItemKind.Constant:
                return 'constant';
            case languageclient_1.CompletionItemKind.Method:
                return 'method';
            case languageclient_1.CompletionItemKind.Function:
            case languageclient_1.CompletionItemKind.Constructor:
                return 'function';
            case languageclient_1.CompletionItemKind.Field:
            case languageclient_1.CompletionItemKind.Property:
                return 'property';
            case languageclient_1.CompletionItemKind.Variable:
                return 'variable';
            case languageclient_1.CompletionItemKind.Class:
                return 'class';
            case languageclient_1.CompletionItemKind.Struct:
            case languageclient_1.CompletionItemKind.TypeParameter:
                return 'type';
            case languageclient_1.CompletionItemKind.Operator:
                return 'selector';
            case languageclient_1.CompletionItemKind.Interface:
                return 'mixin';
            case languageclient_1.CompletionItemKind.Module:
                return 'module';
            case languageclient_1.CompletionItemKind.Unit:
                return 'builtin';
            case languageclient_1.CompletionItemKind.Enum:
            case languageclient_1.CompletionItemKind.EnumMember:
                return 'enum';
            case languageclient_1.CompletionItemKind.Keyword:
                return 'keyword';
            case languageclient_1.CompletionItemKind.Snippet:
                return 'snippet';
            case languageclient_1.CompletionItemKind.File:
            case languageclient_1.CompletionItemKind.Folder:
                return 'import';
            case languageclient_1.CompletionItemKind.Reference:
                return 'require';
            default:
                return 'value';
        }
    }
}
exports.default = AutocompleteAdapter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0b2NvbXBsZXRlLWFkYXB0ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9saWIvYWRhcHRlcnMvYXV0b2NvbXBsZXRlLWFkYXB0ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSx3Q0FBaUM7QUFDakMsa0NBQWtDO0FBR2xDLHFEQUF5QztBQUN6QyxzREFXMkI7QUFDM0IsK0JBR2M7QUF3QmQsTUFBTSw4QkFBOEI7SUFDbEMsWUFDUyxjQUE4QixFQUM5QixVQUFtQjtRQURuQixtQkFBYyxHQUFkLGNBQWMsQ0FBZ0I7UUFDOUIsZUFBVSxHQUFWLFVBQVUsQ0FBUztJQUU1QixDQUFDO0NBQ0Y7QUFFRDs7O0dBR0c7QUFDSCxNQUFxQixtQkFBbUI7SUFBeEM7UUFVVSxxQkFBZ0IsR0FBZ0QsSUFBSSxPQUFPLEVBQUUsQ0FBQztRQUM5RSx3QkFBbUIsR0FBK0QsSUFBSSxPQUFPLEVBQUUsQ0FBQztJQTRiMUcsQ0FBQztJQXRjUSxNQUFNLENBQUMsUUFBUSxDQUFDLGtCQUFzQztRQUMzRCxPQUFPLGtCQUFrQixDQUFDLGtCQUFrQixJQUFJLElBQUksQ0FBQztJQUN2RCxDQUFDO0lBRU0sTUFBTSxDQUFDLFVBQVUsQ0FBQyxrQkFBc0M7UUFDN0QsT0FBTyxrQkFBa0IsQ0FBQyxrQkFBa0IsSUFBSSxJQUFJO1lBQ2xELGtCQUFrQixDQUFDLGtCQUFrQixDQUFDLGVBQWUsS0FBSyxJQUFJLENBQUM7SUFDbkUsQ0FBQztJQUtEOzs7Ozs7Ozs7OztPQVdHO0lBQ1UsY0FBYyxDQUN6QixNQUFvQixFQUNwQixPQUFxQyxFQUNyQywwQkFBbUQsRUFDbkQsaUJBQTBCOztZQUUxQixNQUFNLFlBQVksR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDLGtCQUFrQixJQUFJLElBQUk7Z0JBQ2pFLENBQUMsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLGtCQUFrQixDQUFDLGlCQUFpQixJQUFJLEVBQUU7Z0JBQ2hFLENBQUMs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QUFTLENBQUM7WUFDbkIsS0FBSyxtQ0FBa0IsQ0FBQyxJQUFJLENBQUM7WUFDN0IsS0FBSyxtQ0FBa0IsQ0FBQyxNQUFNO2dCQUM1QixPQUFPLFFBQVEsQ0FBQztZQUNsQixLQUFLLG1DQUFrQixDQUFDLFNBQVM7Z0JBQy9CLE9BQU8sU0FBUyxDQUFDO1lBQ25CO2dCQUNFLE9BQU8sT0FBTyxDQUFDO1NBQ2xCO0lBQ0gsQ0FBQztDQUNGO0FBdmNELHNDQXVjQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDb252ZXJ0IGZyb20gJy4uL2NvbnZlcnQnO1xuaW1wb3J0ICogYXMgVXRpbHMgZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UgfSBmcm9tICd2c2NvZGUtanNvbnJwYyc7XG5pbXBvcnQgeyBBY3RpdmVTZXJ2ZXIgfSBmcm9tICcuLi9zZXJ2ZXItbWFuYWdlcic7XG5pbXBvcnQgeyBmaWx0ZXIgfSBmcm9tICdmdXp6YWxkcmluLXBsdXMnO1xuaW1wb3J0IHtcbiAgQ29tcGxldGlvbkNvbnRleHQsXG4gIENvbXBsZXRpb25JdGVtLFxuICBDb21wbGV0aW9uSXRlbUtpbmQsXG4gIENvbXBsZXRpb25MaXN0LFxuICBDb21wbGV0aW9uUGFyYW1zLFxuICBDb21wbGV0aW9uVHJpZ2dlcktpbmQsXG4gIEluc2VydFRleHRGb3JtYXQsXG4gIExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcbiAgU2VydmVyQ2FwYWJpbGl0aWVzLFxuICBUZXh0RWRpdCxcbn0gZnJvbSAnLi4vbGFuZ3VhZ2VjbGllbnQnO1xuaW1wb3J0IHtcbiAgUG9pbnQsXG4gIFRleHRFZGl0b3IsXG59IGZyb20gJ2F0b20nO1xuaW1wb3J0ICogYXMgYWMgZnJvbSAnYXRvbS9hdXRvY29tcGxldGUtcGx1cyc7XG5pbXBvcnQgeyBTdWdnZXN0aW9uLCBUZXh0U3VnZ2VzdGlvbiwgU25pcHBldFN1Z2dlc3Rpb24gfSBmcm9tICdhdG9tLWlkZSc7XG5cbi8qKlxuICogSG9sZHMgYSBsaXN0IG9mIHN1Z2dlc3Rpb25zIGdlbmVyYXRlZCBmcm9tIHRoZSBDb21wbGV0aW9uSXRlbVtdXG4gKiBsaXN0IHNlbnQgYnkgdGhlIHNlcnZlciwgYXMgd2VsbCBhcyBtZXRhZGF0YSBhYm91dCB0aGUgY29udGV4dFxuICogaXQgd2FzIGNvbGxlY3RlZCBpblxuICovXG5pbnRlcmZhY2UgU3VnZ2VzdGlvbkNhY2hlRW50cnkge1xuICAvKiogSWYgYHRydWVgLCB0aGUgc2VydmVyIHdpbGwgc2VuZCBhIGxpc3Qgb2Ygc3VnZ2VzdGlvbnMgdG8gcmVwbGFjZSB0aGlzIG9uZSAqL1xuICBpc0luY29tcGxldGU6IGJvb2xlYW47XG4gIC8qKiBUaGUgcG9pbnQgbGVmdCBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZSBvcmlnaW5hbCBwcmVmaXggc2VudCB0byB0aGUgc2VydmVyICovXG4gIHRyaWdnZXJQb2ludDogUG9pbnQ7XG4gIC8qKiBUaGUgcG9pbnQgcmlnaHQgb2YgdGhlIGxhc3QgY2hhcmFjdGVyIGluIHRoZSBvcmlnaW5hbCBwcmVmaXggc2VudCB0byB0aGUgc2VydmVyICovXG4gIG9yaWdpbmFsQnVmZmVyUG9pbnQ6IFBvaW50O1xuICAvKiogVGhlIHRyaWdnZXIgc3RyaW5nIHRoYXQgY2F1c2VkIHRoZSBhdXRvY29tcGxldGUgKGlmIGFueSkgKi9cbiAgdHJpZ2dlckNoYXI6IHN0cmluZztcbiAgc3VnZ2VzdGlvbk1hcDogTWFwPFN1Z2dlc3Rpb24sIFBvc3NpYmx5UmVzb2x2ZWRDb21wbGV0aW9uSXRlbT47XG59XG5cbnR5cGUgQ29tcGxldGlvbkl0ZW1BZGp1c3RlciA9XG4gIChpdGVtOiBDb21wbGV0aW9uSXRlbSwgc3VnZ2VzdGlvbjogYWMuQW55U3VnZ2VzdGlvbiwgcmVxdWVzdDogYWMuU3VnZ2VzdGlvbnNSZXF1ZXN0ZWRFdmVudCkgPT4gdm9pZDtcblxuY2xhc3MgUG9zc2libHlSZXNvbHZlZENvbXBsZXRpb25JdGVtIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIGNvbXBsZXRpb25JdGVtOiBDb21wbGV0aW9uSXRlbSxcbiAgICBwdWJsaWMgaXNSZXNvbHZlZDogYm9vbGVhbixcbiAgKSB7XG4gIH1cbn1cblxuLyoqXG4gKiBQdWJsaWM6IEFkYXB0cyB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHByb3RvY29sIFwidGV4dERvY3VtZW50L2NvbXBsZXRpb25cIiB0byB0aGUgQXRvbVxuICogQXV0b0NvbXBsZXRlKyBwYWNrYWdlLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBdXRvY29tcGxldGVBZGFwdGVyIHtcbiAgcHVibGljIHN0YXRpYyBjYW5BZGFwdChzZXJ2ZXJDYXBhYmlsaXRpZXM6IFNlcnZlckNhcGFiaWxpdGllcyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBzZXJ2ZXJDYXBhYmlsaXRpZXMuY29tcGxldGlvblByb3ZpZGVyICE9IG51bGw7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGNhblJlc29sdmUoc2VydmVyQ2FwYWJpbGl0aWVzOiBTZXJ2ZXJDYXBhYmlsaXRpZXMpOiBib29sZWFuIHtcbiAgICByZXR1cm4gc2VydmVyQ2FwYWJpbGl0aWVzLmNvbXBsZXRpb25Qcm92aWRlciAhPSBudWxsICYmXG4gICAgICBzZXJ2ZXJDYXBhYmlsaXRpZXMuY29tcGxldGlvblByb3ZpZGVyLnJlc29sdmVQcm92aWRlciA9PT0gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgX3N1Z2dlc3Rpb25DYWNoZTogV2Vha01hcDxBY3RpdmVTZXJ2ZXIsIFN1Z2dlc3Rpb25DYWNoZUVudHJ5PiA9IG5ldyBXZWFrTWFwKCk7XG4gIHByaXZhdGUgX2NhbmNlbGxhdGlvblRva2VuczogV2Vha01hcDxMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sIENhbmNlbGxhdGlvblRva2VuU291cmNlPiA9IG5ldyBXZWFrTWFwKCk7XG5cbiAgLyoqXG4gICAqIFB1YmxpYzogT2J0YWluIHN1Z2dlc3Rpb24gbGlzdCBmb3IgQXV0b0NvbXBsZXRlKyBieSBxdWVyeWluZyB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHVzaW5nXG4gICAqIHRoZSBgdGV4dERvY3VtZW50L2NvbXBsZXRpb25gIHJlcXVlc3QuXG4gICAqXG4gICAqIEBwYXJhbSBzZXJ2ZXIgQW4ge0FjdGl2ZVNlcnZlcn0gcG9pbnRpbmcgdG8gdGhlIGxhbmd1YWdlIHNlcnZlciB0byBxdWVyeS5cbiAgICogQHBhcmFtIHJlcXVlc3QgVGhlIHthdG9tJEF1dG9jb21wbGV0ZVJlcXVlc3R9IHRvIHNhdGlzZnkuXG4gICAqIEBwYXJhbSBvbkRpZENvbnZlcnRDb21wbGV0aW9uSXRlbSBBbiBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IHRha2VzIGEge0NvbXBsZXRpb25JdGVtfSxcbiAgICogICBhbiB7YXRvbSRBdXRvY29tcGxldGVTdWdnZXN0aW9ufSBhbmQgYSB7YXRvbSRBdXRvY29tcGxldGVSZXF1ZXN0fVxuICAgKiAgIGFsbG93aW5nIHlvdSB0byBhZGp1c3QgY29udmVydGVkIGl0ZW1zLlxuICAgKiBAcmV0dXJucyBBIHtQcm9taXNlfSBvZiBhbiB7QXJyYXl9IG9mIHthdG9tJEF1dG9jb21wbGV0ZVN1Z2dlc3Rpb259cyBjb250YWluaW5nIHRoZVxuICAgKiAgIEF1dG9Db21wbGV0ZSsgc3VnZ2VzdGlvbnMgdG8gZGlzcGxheS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBnZXRTdWdnZXN0aW9ucyhcbiAgICBzZXJ2ZXI6IEFjdGl2ZVNlcnZlcixcbiAgICByZXF1ZXN0OiBhYy5TdWdnZXN0aW9uc1JlcXVlc3RlZEV2ZW50LFxuICAgIG9uRGlkQ29udmVydENvbXBsZXRpb25JdGVtPzogQ29tcGxldGlvbkl0ZW1BZGp1c3RlcixcbiAgICBtaW5pbXVtV29yZExlbmd0aD86IG51bWJlcixcbiAgKTogUHJvbWlzZTxhYy5BbnlTdWdnZXN0aW9uW10+IHtcbiAgICBjb25zdCB0cmlnZ2VyQ2hhcnMgPSBzZXJ2ZXIuY2FwYWJpbGl0aWVzLmNvbXBsZXRpb25Qcm92aWRlciAhPSBudWxsXG4gICAgICA/IHNlcnZlci5jYXBhYmlsaXRpZXMuY29tcGxldGlvblByb3ZpZGVyLnRyaWdnZXJDaGFyYWN0ZXJzIHx8IFtdXG4gICAgICA6IFtdO1xuXG4gICAgLy8gdHJpZ2dlck9ubHkgaXMgdHJ1ZSBpZiB3ZSBoYXZlIGp1c3QgdHlwZWQgaW4gYSB0cmlnZ2VyIGNoYXJhY3RlciwgYW5kIGlzIGZhbHNlIGlmIHdlXG4gICAgLy8gaGF2ZSB0eXBlZCBhZGRpdGlvbmFsIGNoYXJhY3RlcnMgZm9sbG93aW5nIGEgdHJpZ2dlciBjaGFyYWN0ZXIuXG4gICAgY29uc3QgW3RyaWdnZXJDaGFyLCB0cmlnZ2VyT25seV0gPSBBdXRvY29tcGxldGVBZGFwdGVyLmdldFRyaWdnZXJDaGFyYWN0ZXIocmVxdWVzdCwgdHJpZ2dlckNoYXJzKTtcblxuICAgIGlmICghdGhpcy5zaG91bGRUcmlnZ2VyKHJlcXVlc3QsIHRyaWdnZXJDaGFyLCBtaW5pbXVtV29yZExlbmd0aCB8fCAwKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIC8vIEdldCB0aGUgc3VnZ2VzdGlvbnMgZWl0aGVyIGZyb20gdGhlIGNhY2hlIG9yIGJ5IGNhbGxpbmcgdGhlIGxhbmd1YWdlIHNlcnZlclxuICAgIGNvbnN0IHN1Z2dlc3Rpb25zID0gYXdhaXRcbiAgICAgIHRoaXMuZ2V0T3JCdWlsZFN1Z2dlc3Rpb25zKHNlcnZlciwgcmVxdWVzdCwgdHJpZ2dlckNoYXIsIHRyaWdnZXJPbmx5LCBvbkRpZENvbnZlcnRDb21wbGV0aW9uSXRlbSk7XG5cbiAgICAvLyBXZSBtdXN0IHVwZGF0ZSB0aGUgcmVwbGFjZW1lbnQgcHJlZml4IGFzIGNoYXJhY3RlcnMgYXJlIGFkZGVkIGFuZCByZW1vdmVkXG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLl9zdWdnZXN0aW9uQ2FjaGUuZ2V0KHNlcnZlcikhO1xuICAgIGNvbnN0IHJlcGxhY2VtZW50UHJlZml4ID0gcmVxdWVzdC5lZGl0b3IuZ2V0VGV4dEluQnVmZmVyUmFuZ2UoW2NhY2hlLnRyaWdnZXJQb2ludCwgcmVxdWVzdC5idWZmZXJQb3NpdGlvbl0pO1xuICAgIGZvciAoY29uc3Qgc3VnZ2VzdGlvbiBvZiBzdWdnZXN0aW9ucykge1xuICAgICAgaWYgKHN1Z2dlc3Rpb24uY3VzdG9tUmVwbGFjbWVudFByZWZpeCkgeyAvLyBoYXZpbmcgdGhpcyBwcm9wZXJ0eSBtZWFucyBhIGN1c3RvbSByYW5nZSB3YXMgcHJvdmlkZWRcbiAgICAgICAgY29uc3QgbGVuID0gcmVwbGFjZW1lbnRQcmVmaXgubGVuZ3RoO1xuICAgICAgICBjb25zdCBwcmVSZXBsYWNlbWVudFByZWZpeCA9IHN1Z2dlc3Rpb24uY3VzdG9tUmVwbGFjbWVudFByZWZpeFxuICAgICAgICAgICsgcmVwbGFjZW1lbnRQcmVmaXguc3Vic3RyaW5nKGxlbiArIGNhY2hlLm9yaWdpbmFsQnVmZmVyUG9pbnQuY29sdW1uIC0gcmVxdWVzdC5idWZmZXJQb3NpdGlvbi5jb2x1bW4sIGxlbik7XG4gICAgICAgIC8vIHdlIGNhbm5vdCByZXBsYWNlIHRleHQgYWZ0ZXIgdGhlIGN1cnNvciB3aXRoIHRoZSBjdXJyZW50IGF1dG9jb21wbGV0ZS1wbHVzIEFQSVxuICAgICAgICAvLyBzbyB3ZSB3aWxsIHNpbXBseSBpZ25vcmUgaXQgZm9yIG5vd1xuICAgICAgICBzdWdnZXN0aW9uLnJlcGxhY2VtZW50UHJlZml4ID0gcHJlUmVwbGFjZW1lbnRQcmVmaXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdWdnZXN0aW9uLnJlcGxhY2VtZW50UHJlZml4ID0gcmVwbGFjZW1lbnRQcmVmaXg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZmlsdGVyZWQgPSAhKHJlcXVlc3QucHJlZml4ID09PSBcIlwiIHx8ICh0cmlnZ2VyQ2hhciAhPT0gJycgJiYgdHJpZ2dlck9ubHkpKTtcbiAgICByZXR1cm4gZmlsdGVyZWQgPyBmaWx0ZXIoc3VnZ2VzdGlvbnMsIHJlcXVlc3QucHJlZml4LCB7IGtleTogJ2ZpbHRlclRleHQnIH0pIDogc3VnZ2VzdGlvbnM7XG4gIH1cblxuICBwcml2YXRlIHNob3VsZFRyaWdnZXIoXG4gICAgcmVxdWVzdDogYWMuU3VnZ2VzdGlvbnNSZXF1ZXN0ZWRFdmVudCxcbiAgICB0cmlnZ2VyQ2hhcjogc3RyaW5nLFxuICAgIG1pbldvcmRMZW5ndGg6IG51bWJlcixcbiAgKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHJlcXVlc3QuYWN0aXZhdGVkTWFudWFsbHlcbiAgICAgIHx8IHRyaWdnZXJDaGFyICE9PSAnJ1xuICAgICAgfHwgbWluV29yZExlbmd0aCA8PSAwXG4gICAgICB8fCByZXF1ZXN0LnByZWZpeC5sZW5ndGggPj0gbWluV29yZExlbmd0aDtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2V0T3JCdWlsZFN1Z2dlc3Rpb25zKFxuICAgIHNlcnZlcjogQWN0aXZlU2VydmVyLFxuICAgIHJlcXVlc3Q6IGFjLlN1Z2dlc3Rpb25zUmVxdWVzdGVkRXZlbnQsXG4gICAgdHJpZ2dlckNoYXI6IHN0cmluZyxcbiAgICB0cmlnZ2VyT25seTogYm9vbGVhbixcbiAgICBvbkRpZENvbnZlcnRDb21wbGV0aW9uSXRlbT86IENvbXBsZXRpb25JdGVtQWRqdXN0ZXIsXG4gICk6IFByb21pc2U8U3VnZ2VzdGlvbltdPiB7XG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLl9zdWdnZXN0aW9uQ2FjaGUuZ2V0KHNlcnZlcik7XG5cbiAgICBjb25zdCB0cmlnZ2VyQ29sdW1uID0gKHRyaWdnZXJDaGFyICE9PSAnJyAmJiB0cmlnZ2VyT25seSlcbiAgICAgID8gcmVxdWVzdC5idWZmZXJQb3NpdGlvbi5jb2x1bW4gLSB0cmlnZ2VyQ2hhci5sZW5ndGhcbiAgICAgIDogcmVxdWVzdC5idWZmZXJQb3NpdGlvbi5jb2x1bW4gLSByZXF1ZXN0LnByZWZpeC5sZW5ndGggLSB0cmlnZ2VyQ2hhci5sZW5ndGg7XG4gICAgY29uc3QgdHJpZ2dlclBvaW50ID0gbmV3IFBvaW50KHJlcXVlc3QuYnVmZmVyUG9zaXRpb24ucm93LCB0cmlnZ2VyQ29sdW1uKTtcblxuICAgIC8vIERvIHdlIGhhdmUgY29tcGxldGUgY2FjaGVkIHN1Z2dlc3Rpb25zIHRoYXQgYXJlIHN0aWxsIHZhbGlkIGZvciB0aGlzIHJlcXVlc3Q/XG4gICAgaWYgKGNhY2hlICYmICFjYWNoZS5pc0luY29tcGxldGUgJiYgY2FjaGUudHJpZ2dlckNoYXIgPT09IHRyaWdnZXJDaGFyXG4gICAgICAmJiBjYWNoZS50cmlnZ2VyUG9pbnQuaXNFcXVhbCh0cmlnZ2VyUG9pbnQpXG4gICAgICAmJiBjYWNoZS5vcmlnaW5hbEJ1ZmZlclBvaW50LmlzTGVzc1RoYW5PckVxdWFsKHJlcXVlc3QuYnVmZmVyUG9zaXRpb24pKSB7XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShjYWNoZS5zdWdnZXN0aW9uTWFwLmtleXMoKSk7XG4gICAgfVxuXG4gICAgLy8gT3VyIGNhY2hlZCBzdWdnZXN0aW9ucyBjYW4ndCBiZSB1c2VkIHNvIG9idGFpbiBuZXcgb25lcyBmcm9tIHRoZSBsYW5ndWFnZSBzZXJ2ZXJcbiAgICBjb25zdCBjb21wbGV0aW9ucyA9IGF3YWl0IFV0aWxzLmRvV2l0aENhbmNlbGxhdGlvblRva2VuKHNlcnZlci5jb25uZWN0aW9uLCB0aGlzLl9jYW5jZWxsYXRpb25Ub2tlbnMsXG4gICAgICAoY2FuY2VsbGF0aW9uVG9rZW4pID0+IHNlcnZlci5jb25uZWN0aW9uLmNvbXBsZXRpb24oXG4gICAgICAgIEF1dG9jb21wbGV0ZUFkYXB0ZXIuY3JlYXRlQ29tcGxldGlvblBhcmFtcyhyZXF1ZXN0LCB0cmlnZ2VyQ2hhciwgdHJpZ2dlck9ubHkpLCBjYW5jZWxsYXRpb25Ub2tlbiksXG4gICAgKTtcblxuICAgIC8vIHNwZWMgZ3VhcmFudGVlcyBhbGwgZWRpdHMgYXJlIG9uIHRoZSBzYW1lIGxpbmUsIHNvIHdlIG9ubHkgbmVlZCB0byBjaGVjayB0aGUgY29sdW1uc1xuICAgIGNvbnN0IHRyaWdnZXJDb2x1bW5zOiBbbnVtYmVyLCBudW1iZXJdID0gW3RyaWdnZXJQb2ludC5jb2x1bW4sIHJlcXVlc3QuYnVmZmVyUG9zaXRpb24uY29sdW1uXTtcblxuICAgIC8vIFNldHVwIHRoZSBjYWNoZSBmb3Igc3Vic2VxdWVudCBmaWx0ZXJlZCByZXN1bHRzXG4gICAgY29uc3QgaXNDb21wbGV0ZSA9IGNvbXBsZXRpb25zID09PSBudWxsIHx8IEFycmF5LmlzQXJyYXkoY29tcGxldGlvbnMpIHx8IGNvbXBsZXRpb25zLmlzSW5jb21wbGV0ZSA9PT0gZmFsc2U7XG4gICAgY29uc3Qgc3VnZ2VzdGlvbk1hcCA9XG4gICAgICB0aGlzLmNvbXBsZXRpb25JdGVtc1RvU3VnZ2VzdGlvbnMoY29tcGxldGlvbnMsIHJlcXVlc3QsIHRyaWdnZXJDb2x1bW5zLCBvbkRpZENvbnZlcnRDb21wbGV0aW9uSXRlbSk7XG4gICAgdGhpcy5fc3VnZ2VzdGlvbkNhY2hlLnNldChzZXJ2ZXIsIHtcbiAgICAgIGlzSW5jb21wbGV0ZTogIWlzQ29tcGxldGUsXG4gICAgICB0cmlnZ2VyQ2hhcixcbiAgICAgIHRyaWdnZXJQb2ludCxcbiAgICAgIG9yaWdpbmFsQnVmZmVyUG9pbnQ6IHJlcXVlc3QuYnVmZmVyUG9zaXRpb24sXG4gICAgICBzdWdnZXN0aW9uTWFwLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIEFycmF5LmZyb20oc3VnZ2VzdGlvbk1hcC5rZXlzKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYzogT2J0YWluIGEgY29tcGxldGUgdmVyc2lvbiBvZiBhIHN1Z2dlc3Rpb24gd2l0aCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gICAqIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgY2FuIHByb3ZpZGUgYnkgd2F5IG9mIHRoZSBgY29tcGxldGlvbkl0ZW0vcmVzb2x2ZWAgcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtIHNlcnZlciBBbiB7QWN0aXZlU2VydmVyfSBwb2ludGluZyB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0gc3VnZ2VzdGlvbiBBbiB7YXRvbSRBdXRvY29tcGxldGVTdWdnZXN0aW9ufSBzdWdnZXN0aW9uIHRoYXQgc2hvdWxkIGJlIHJlc29sdmVkLlxuICAgKiBAcGFyYW0gcmVxdWVzdCBBbiB7T2JqZWN0fSB3aXRoIHRoZSBBdXRvQ29tcGxldGUrIHJlcXVlc3QgdG8gc2F0aXNmeS5cbiAgICogQHBhcmFtIG9uRGlkQ29udmVydENvbXBsZXRpb25JdGVtIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB7Q29tcGxldGlvbkl0ZW19LCBhblxuICAgKiAgIHthdG9tJEF1dG9jb21wbGV0ZVN1Z2dlc3Rpb259IGFuZCBhIHthdG9tJEF1dG9jb21wbGV0ZVJlcXVlc3R9IGFsbG93aW5nIHlvdSB0byBhZGp1c3QgY29udmVydGVkIGl0ZW1zLlxuICAgKiBAcmV0dXJucyBBIHtQcm9taXNlfSBvZiBhbiB7YXRvbSRBdXRvY29tcGxldGVTdWdnZXN0aW9ufSB3aXRoIHRoZSByZXNvbHZlZCBBdXRvQ29tcGxldGUrIHN1Z2dlc3Rpb24uXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgY29tcGxldGVTdWdnZXN0aW9uKFxuICAgIHNlcnZlcjogQWN0aXZlU2VydmVyLFxuICAgIHN1Z2dlc3Rpb246IGFjLkFueVN1Z2dlc3Rpb24sXG4gICAgcmVxdWVzdDogYWMuU3VnZ2VzdGlvbnNSZXF1ZXN0ZWRFdmVudCxcbiAgICBvbkRpZENvbnZlcnRDb21wbGV0aW9uSXRlbT86IENvbXBsZXRpb25JdGVtQWRqdXN0ZXIsXG4gICk6IFByb21pc2U8YWMuQW55U3VnZ2VzdGlvbj4ge1xuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fc3VnZ2VzdGlvbkNhY2hlLmdldChzZXJ2ZXIpO1xuICAgIGlmIChjYWNoZSkge1xuICAgICAgY29uc3QgcG9zc2libHlSZXNvbHZlZENvbXBsZXRpb25JdGVtID0gY2FjaGUuc3VnZ2VzdGlvbk1hcC5nZXQoc3VnZ2VzdGlvbik7XG4gICAgICBpZiAocG9zc2libHlSZXNvbHZlZENvbXBsZXRpb25JdGVtICE9IG51bGwgJiYgcG9zc2libHlSZXNvbHZlZENvbXBsZXRpb25JdGVtLmlzUmVzb2x2ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkQ29tcGxldGlvbkl0ZW0gPSBhd2FpdFxuICAgICAgICAgIHNlcnZlci5jb25uZWN0aW9uLmNvbXBsZXRpb25JdGVtUmVzb2x2ZShwb3NzaWJseVJlc29sdmVkQ29tcGxldGlvbkl0ZW0uY29tcGxldGlvbkl0ZW0pO1xuICAgICAgICBpZiAocmVzb2x2ZWRDb21wbGV0aW9uSXRlbSAhPSBudWxsKSB7XG4gICAgICAgICAgQXV0b2NvbXBsZXRlQWRhcHRlci5yZXNvbHZlU3VnZ2VzdGlvbihcbiAgICAgICAgICAgIHJlc29sdmVkQ29tcGxldGlvbkl0ZW0sIHN1Z2dlc3Rpb24sIHJlcXVlc3QsIG9uRGlkQ29udmVydENvbXBsZXRpb25JdGVtKTtcbiAgICAgICAgICBwb3NzaWJseVJlc29sdmVkQ29tcGxldGlvbkl0ZW0uaXNSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1Z2dlc3Rpb247XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIHJlc29sdmVTdWdnZXN0aW9uKFxuICAgIHJlc29sdmVkQ29tcGxldGlvbkl0ZW06IENvbXBsZXRpb25JdGVtLFxuICAgIHN1Z2dlc3Rpb246IGFjLkFueVN1Z2dlc3Rpb24sXG4gICAgcmVxdWVzdDogYWMuU3VnZ2VzdGlvbnNSZXF1ZXN0ZWRFdmVudCxcbiAgICBvbkRpZENvbnZlcnRDb21wbGV0aW9uSXRlbT86IENvbXBsZXRpb25JdGVtQWRqdXN0ZXIsXG4gICk6IHZvaWQge1xuICAgIC8vIG9ubHkgdGhlIGBkb2N1bWVudGF0aW9uYCBhbmQgYGRldGFpbGAgcHJvcGVydGllcyBtYXkgY2hhbmdlIHdoZW4gcmVzb2x2aW5nXG4gICAgQXV0b2NvbXBsZXRlQWRhcHRlci5hcHBseURldGFpbHNUb1N1Z2dlc3Rpb24ocmVzb2x2ZWRDb21wbGV0aW9uSXRlbSwgc3VnZ2VzdGlvbik7XG4gICAgaWYgKG9uRGlkQ29udmVydENvbXBsZXRpb25JdGVtICE9IG51bGwpIHtcbiAgICAgIG9uRGlkQ29udmVydENvbXBsZXRpb25JdGVtKHJlc29sdmVkQ29tcGxldGlvbkl0ZW0sIHN1Z2dlc3Rpb24gYXMgYWMuQW55U3VnZ2VzdGlvbiwgcmVxdWVzdCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYzogR2V0IHRoZSB0cmlnZ2VyIGNoYXJhY3RlciB0aGF0IGNhdXNlZCB0aGUgYXV0b2NvbXBsZXRlIChpZiBhbnkpLiAgVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlXG4gICAqIEF1dG9Db21wbGV0ZS1wbHVzIGRvZXMgbm90IGhhdmUgdHJpZ2dlciBjaGFyYWN0ZXJzLiAgQWx0aG91Z2ggdGhlIHRlcm1pbm9sb2d5IGlzICdjaGFyYWN0ZXInIHdlIHRyZWF0XG4gICAqIHRoZW0gYXMgdmFyaWFibGUgbGVuZ3RoIHN0cmluZ3MgYXMgdGhpcyB3aWxsIGFsbW9zdCBjZXJ0YWlubHkgY2hhbmdlIGluIHRoZSBmdXR1cmUgdG8gc3VwcG9ydCAnLT4nIGV0Yy5cbiAgICpcbiAgICogQHBhcmFtIHJlcXVlc3QgQW4ge0FycmF5fSBvZiB7YXRvbSRBdXRvY29tcGxldGVTdWdnZXN0aW9ufXMgdG8gbG9jYXRlIHRoZSBwcmVmaXgsIGVkaXRvciwgYnVmZmVyUG9zaXRpb24gZXRjLlxuICAgKiBAcGFyYW0gdHJpZ2dlckNoYXJzIFRoZSB7QXJyYXl9IG9mIHtzdHJpbmd9cyB0aGF0IGNhbiBiZSB0cmlnZ2VyIGNoYXJhY3RlcnMuXG4gICAqIEByZXR1cm5zIEEgW3tzdHJpbmd9LCBib29sZWFuXSB3aGVyZSB0aGUgc3RyaW5nIGlzIHRoZSBtYXRjaGluZyB0cmlnZ2VyIGNoYXJhY3RlciBvciBhbiBlbXB0eSBzdHJpbmdcbiAgICogICBpZiBvbmUgd2FzIG5vdCBtYXRjaGVkLCBhbmQgdGhlIGJvb2xlYW4gaXMgdHJ1ZSBpZiB0aGUgdHJpZ2dlciBjaGFyYWN0ZXIgaXMgaW4gcmVxdWVzdC5wcmVmaXgsIGFuZCBmYWxzZVxuICAgKiAgIGlmIGl0IGlzIGluIHRoZSB3b3JkIGJlZm9yZSByZXF1ZXN0LnByZWZpeC4gVGhlIGJvb2xlYW4gcmV0dXJuIHZhbHVlIGhhcyBubyBtZWFuaW5nIGlmIHRoZSBzdHJpbmcgcmV0dXJuXG4gICAqICAgdmFsdWUgaXMgYW4gZW1wdHkgc3RyaW5nLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBnZXRUcmlnZ2VyQ2hhcmFjdGVyKFxuICAgIHJlcXVlc3Q6IGFjLlN1Z2dlc3Rpb25zUmVxdWVzdGVkRXZlbnQsXG4gICAgdHJpZ2dlckNoYXJzOiBzdHJpbmdbXSxcbiAgKTogW3N0cmluZywgYm9vbGVhbl0ge1xuICAgIC8vIEF1dG9Db21wbGV0ZS1QbHVzIGNvbnNpZGVycyB0ZXh0IGFmdGVyIGEgc3ltYm9sIHRvIGJlIGEgbmV3IHRyaWdnZXIuIFNvIHdlIHNob3VsZCBsb29rIGJhY2t3YXJkXG4gICAgLy8gZnJvbSB0aGUgY3VycmVudCBjdXJzb3IgcG9zaXRpb24gdG8gc2VlIGlmIG9uZSBpcyB0aGVyZSBhbmQgdGh1cyBzaW11bGF0ZSBpdC5cbiAgICBjb25zdCBidWZmZXIgPSByZXF1ZXN0LmVkaXRvci5nZXRCdWZmZXIoKTtcbiAgICBjb25zdCBjdXJzb3IgPSByZXF1ZXN0LmJ1ZmZlclBvc2l0aW9uO1xuICAgIGNvbnN0IHByZWZpeFN0YXJ0Q29sdW1uID0gY3Vyc29yLmNvbHVtbiAtIHJlcXVlc3QucHJlZml4Lmxlbmd0aDtcbiAgICBmb3IgKGNvbnN0IHRyaWdnZXJDaGFyIG9mIHRyaWdnZXJDaGFycykge1xuICAgICAgaWYgKHJlcXVlc3QucHJlZml4LmVuZHNXaXRoKHRyaWdnZXJDaGFyKSkge1xuICAgICAgICByZXR1cm4gW3RyaWdnZXJDaGFyLCB0cnVlXTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmVmaXhTdGFydENvbHVtbiA+PSB0cmlnZ2VyQ2hhci5sZW5ndGgpIHsgLy8gRmFyIGVub3VnaCBhbG9uZyBhIGxpbmUgdG8gZml0IHRoZSB0cmlnZ2VyIGNoYXJcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBuZXcgUG9pbnQoY3Vyc29yLnJvdywgcHJlZml4U3RhcnRDb2x1bW4gLSB0cmlnZ2VyQ2hhci5sZW5ndGgpO1xuICAgICAgICBjb25zdCBwb3NzaWJsZVRyaWdnZXIgPSBidWZmZXIuZ2V0VGV4dEluUmFuZ2UoW3N0YXJ0LCBbY3Vyc29yLnJvdywgcHJlZml4U3RhcnRDb2x1bW5dXSk7XG4gICAgICAgIGlmIChwb3NzaWJsZVRyaWdnZXIgPT09IHRyaWdnZXJDaGFyKSB7IC8vIFRoZSB0ZXh0IGJlZm9yZSBvdXIgdHJpZ2dlciBpcyBhIHRyaWdnZXIgY2hhciFcbiAgICAgICAgICByZXR1cm4gW3RyaWdnZXJDaGFyLCBmYWxzZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGVyZSB3YXMgbm8gZXhwbGljaXQgdHJpZ2dlciBjaGFyXG4gICAgcmV0dXJuIFsnJywgZmFsc2VdO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYzogQ3JlYXRlIFRleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zIHRvIGJlIHNlbnQgdG8gdGhlIGxhbmd1YWdlIHNlcnZlclxuICAgKiBiYXNlZCBvbiB0aGUgZWRpdG9yIGFuZCBwb3NpdGlvbiBmcm9tIHRoZSBBdXRvQ29tcGxldGVSZXF1ZXN0LlxuICAgKlxuICAgKiBAcGFyYW0gcmVxdWVzdCBUaGUge2F0b20kQXV0b2NvbXBsZXRlUmVxdWVzdH0gdG8gb2J0YWluIHRoZSBlZGl0b3IgZnJvbS5cbiAgICogQHBhcmFtIHRyaWdnZXJQb2ludCBUaGUge2F0b20kUG9pbnR9IHdoZXJlIHRoZSB0cmlnZ2VyIHN0YXJ0ZWQuXG4gICAqIEByZXR1cm5zIEEge3N0cmluZ30gY29udGFpbmluZyB0aGUgcHJlZml4IGluY2x1ZGluZyB0aGUgdHJpZ2dlciBjaGFyYWN0ZXIuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGdldFByZWZpeFdpdGhUcmlnZ2VyKFxuICAgIHJlcXVlc3Q6IGFjLlN1Z2dlc3Rpb25zUmVxdWVzdGVkRXZlbnQsXG4gICAgdHJpZ2dlclBvaW50OiBQb2ludCxcbiAgKTogc3RyaW5nIHtcbiAgICByZXR1cm4gcmVxdWVzdC5lZGl0b3JcbiAgICAgIC5nZXRCdWZmZXIoKVxuICAgICAgLmdldFRleHRJblJhbmdlKFtbdHJpZ2dlclBvaW50LnJvdywgdHJpZ2dlclBvaW50LmNvbHVtbl0sIHJlcXVlc3QuYnVmZmVyUG9zaXRpb25dKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWM6IENyZWF0ZSB7Q29tcGxldGlvblBhcmFtc30gdG8gYmUgc2VudCB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyXG4gICAqIGJhc2VkIG9uIHRoZSBlZGl0b3IgYW5kIHBvc2l0aW9uIGZyb20gdGhlIEF1dG9jb21wbGV0ZSByZXF1ZXN0IGV0Yy5cbiAgICpcbiAgICogQHBhcmFtIHJlcXVlc3QgVGhlIHthdG9tJEF1dG9jb21wbGV0ZVJlcXVlc3R9IGNvbnRhaW5pbmcgdGhlIHJlcXVlc3QgZGV0YWlscy5cbiAgICogQHBhcmFtIHRyaWdnZXJDaGFyYWN0ZXIgVGhlIHtzdHJpbmd9IGNvbnRhaW5pbmcgdGhlIHRyaWdnZXIgY2hhcmFjdGVyIChlbXB0eSBpZiBub25lKS5cbiAgICogQHBhcmFtIHRyaWdnZXJPbmx5IEEge2Jvb2xlYW59IHJlcHJlc2VudGluZyB3aGV0aGVyIHRoaXMgY29tcGxldGlvbiBpcyB0cmlnZ2VyZWQgcmlnaHQgYWZ0ZXIgYSB0cmlnZ2VyIGNoYXJhY3Rlci5cbiAgICogQHJldHVybnMgQSB7Q29tcGxldGlvblBhcmFtc30gd2l0aCB0aGUga2V5czpcbiAgICogICAqIGB0ZXh0RG9jdW1lbnRgIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgcHJvdG9jb2wgdGV4dERvY3VtZW50IGlkZW50aWZpY2F0aW9uLlxuICAgKiAgICogYHBvc2l0aW9uYCB0aGUgcG9zaXRpb24gd2l0aGluIHRoZSB0ZXh0IGRvY3VtZW50IHRvIGRpc3BsYXkgY29tcGxldGlvbiByZXF1ZXN0IGZvci5cbiAgICogICAqIGBjb250ZXh0YCBjb250YWluaW5nIHRoZSB0cmlnZ2VyIGNoYXJhY3RlciBhbmQga2luZC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlQ29tcGxldGlvblBhcmFtcyhcbiAgICByZXF1ZXN0OiBhYy5TdWdnZXN0aW9uc1JlcXVlc3RlZEV2ZW50LFxuICAgIHRyaWdnZXJDaGFyYWN0ZXI6IHN0cmluZyxcbiAgICB0cmlnZ2VyT25seTogYm9vbGVhbixcbiAgKTogQ29tcGxldGlvblBhcmFtcyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHREb2N1bWVudDogQ29udmVydC5lZGl0b3JUb1RleHREb2N1bWVudElkZW50aWZpZXIocmVxdWVzdC5lZGl0b3IpLFxuICAgICAgcG9zaXRpb246IENvbnZlcnQucG9pbnRUb1Bvc2l0aW9uKHJlcXVlc3QuYnVmZmVyUG9zaXRpb24pLFxuICAgICAgY29udGV4dDogQXV0b2NvbXBsZXRlQWRhcHRlci5jcmVhdGVDb21wbGV0aW9uQ29udGV4dCh0cmlnZ2VyQ2hhcmFjdGVyLCB0cmlnZ2VyT25seSksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWM6IENyZWF0ZSB7Q29tcGxldGlvbkNvbnRleHR9IHRvIGJlIHNlbnQgdG8gdGhlIGxhbmd1YWdlIHNlcnZlclxuICAgKiBiYXNlZCBvbiB0aGUgdHJpZ2dlciBjaGFyYWN0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB0cmlnZ2VyQ2hhcmFjdGVyIFRoZSB7c3RyaW5nfSBjb250YWluaW5nIHRoZSB0cmlnZ2VyIGNoYXJhY3RlciBvciAnJyBpZiBub25lLlxuICAgKiBAcGFyYW0gdHJpZ2dlck9ubHkgQSB7Ym9vbGVhbn0gcmVwcmVzZW50aW5nIHdoZXRoZXIgdGhpcyBjb21wbGV0aW9uIGlzIHRyaWdnZXJlZCByaWdodCBhZnRlciBhIHRyaWdnZXIgY2hhcmFjdGVyLlxuICAgKiBAcmV0dXJucyBBbiB7Q29tcGxldGlvbkNvbnRleHR9IHRoYXQgc3BlY2lmaWVzIHRoZSB0cmlnZ2VyS2luZCBhbmQgdGhlIHRyaWdnZXJDaGFyYWN0ZXJcbiAgICogICBpZiB0aGVyZSBpcyBvbmUuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGNyZWF0ZUNvbXBsZXRpb25Db250ZXh0KHRyaWdnZXJDaGFyYWN0ZXI6IHN0cmluZywgdHJpZ2dlck9ubHk6IGJvb2xlYW4pOiBDb21wbGV0aW9uQ29udGV4dCB7XG4gICAgaWYgKHRyaWdnZXJDaGFyYWN0ZXIgPT09ICcnKSB7XG4gICAgICByZXR1cm4geyB0cmlnZ2VyS2luZDogQ29tcGxldGlvblRyaWdnZXJLaW5kLkludm9rZWQgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRyaWdnZXJPbmx5XG4gICAgICAgID8geyB0cmlnZ2VyS2luZDogQ29tcGxldGlvblRyaWdnZXJLaW5kLlRyaWdnZXJDaGFyYWN0ZXIsIHRyaWdnZXJDaGFyYWN0ZXIgfVxuICAgICAgICA6IHsgdHJpZ2dlcktpbmQ6IENvbXBsZXRpb25UcmlnZ2VyS2luZC5UcmlnZ2VyRm9ySW5jb21wbGV0ZUNvbXBsZXRpb25zLCB0cmlnZ2VyQ2hhcmFjdGVyIH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYzogQ29udmVydCBhIGxhbmd1YWdlIHNlcnZlciBwcm90b2NvbCBDb21wbGV0aW9uSXRlbSBhcnJheSBvciBDb21wbGV0aW9uTGlzdCB0b1xuICAgKiBhbiBhcnJheSBvZiBvcmRlcmVkIEF1dG9Db21wbGV0ZSsgc3VnZ2VzdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBjb21wbGV0aW9uSXRlbXMgQW4ge0FycmF5fSBvZiB7Q29tcGxldGlvbkl0ZW19IG9iamVjdHMgb3IgYSB7Q29tcGxldGlvbkxpc3R9IGNvbnRhaW5pbmcgY29tcGxldGlvblxuICAgKiAgIGl0ZW1zIHRvIGJlIGNvbnZlcnRlZC5cbiAgICogQHBhcmFtIHJlcXVlc3QgVGhlIHthdG9tJEF1dG9jb21wbGV0ZVJlcXVlc3R9IHRvIHNhdGlzZnkuXG4gICAqIEBwYXJhbSBvbkRpZENvbnZlcnRDb21wbGV0aW9uSXRlbSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB7Q29tcGxldGlvbkl0ZW19LCBhbiB7YXRvbSRBdXRvY29tcGxldGVTdWdnZXN0aW9ufVxuICAgKiAgIGFuZCBhIHthdG9tJEF1dG9jb21wbGV0ZVJlcXVlc3R9IGFsbG93aW5nIHlvdSB0byBhZGp1c3QgY29udmVydGVkIGl0ZW1zLlxuICAgKiBAcmV0dXJucyBBIHtNYXB9IG9mIEF1dG9Db21wbGV0ZSsgc3VnZ2VzdGlvbnMgb3JkZXJlZCBieSB0aGUgQ29tcGxldGlvbkl0ZW1zIHNvcnRUZXh0LlxuICAgKi9cbiAgcHVibGljIGNvbXBsZXRpb25JdGVtc1RvU3VnZ2VzdGlvbnMoXG4gICAgY29tcGxldGlvbkl0ZW1zOiBDb21wbGV0aW9uSXRlbVtdIHwgQ29tcGxldGlvbkxpc3QgfCBudWxsLFxuICAgIHJlcXVlc3Q6IGFjLlN1Z2dlc3Rpb25zUmVxdWVzdGVkRXZlbnQsXG4gICAgdHJpZ2dlckNvbHVtbnM6IFtudW1iZXIsIG51bWJlcl0sXG4gICAgb25EaWRDb252ZXJ0Q29tcGxldGlvbkl0ZW0/OiBDb21wbGV0aW9uSXRlbUFkanVzdGVyLFxuICApOiBNYXA8U3VnZ2VzdGlvbiwgUG9zc2libHlSZXNvbHZlZENvbXBsZXRpb25JdGVtPiB7XG4gICAgY29uc3QgY29tcGxldGlvbnNBcnJheSA9IEFycmF5LmlzQXJyYXkoY29tcGxldGlvbkl0ZW1zKVxuICAgICAgPyBjb21wbGV0aW9uSXRlbXNcbiAgICAgIDogKGNvbXBsZXRpb25JdGVtcyAmJiBjb21wbGV0aW9uSXRlbXMuaXRlbXMpIHx8IFtdO1xuICAgIHJldHVybiBuZXcgTWFwKGNvbXBsZXRpb25zQXJyYXlcbiAgICAgIC5zb3J0KChhLCBiKSA9PiAoYS5zb3J0VGV4dCB8fCBhLmxhYmVsKS5sb2NhbGVDb21wYXJlKGIuc29ydFRleHQgfHwgYi5sYWJlbCkpXG4gICAgICAubWFwPFtTdWdnZXN0aW9uLCBQb3NzaWJseVJlc29sdmVkQ29tcGxldGlvbkl0ZW1dPihcbiAgICAgICAgKHMpID0+IFtcbiAgICAgICAgICBBdXRvY29tcGxldGVBZGFwdGVyLmNvbXBsZXRpb25JdGVtVG9TdWdnZXN0aW9uKFxuICAgICAgICAgICAgcywge30gYXMgU3VnZ2VzdGlvbiwgcmVxdWVzdCwgdHJpZ2dlckNvbHVtbnMsIG9uRGlkQ29udmVydENvbXBsZXRpb25JdGVtKSxcbiAgICAgICAgICBuZXcgUG9zc2libHlSZXNvbHZlZENvbXBsZXRpb25JdGVtKHMsIGZhbHNlKSxcbiAgICAgICAgXSxcbiAgICAgICksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWM6IENvbnZlcnQgYSBsYW5ndWFnZSBzZXJ2ZXIgcHJvdG9jb2wgQ29tcGxldGlvbkl0ZW0gdG8gYW4gQXV0b0NvbXBsZXRlKyBzdWdnZXN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gaXRlbSBBbiB7Q29tcGxldGlvbkl0ZW19IGNvbnRhaW5pbmcgYSBjb21wbGV0aW9uIGl0ZW0gdG8gYmUgY29udmVydGVkLlxuICAgKiBAcGFyYW0gc3VnZ2VzdGlvbiBBIHthdG9tJEF1dG9jb21wbGV0ZVN1Z2dlc3Rpb259IHRvIGhhdmUgdGhlIGNvbnZlcnNpb24gYXBwbGllZCB0by5cbiAgICogQHBhcmFtIHJlcXVlc3QgVGhlIHthdG9tJEF1dG9jb21wbGV0ZVJlcXVlc3R9IHRvIHNhdGlzZnkuXG4gICAqIEBwYXJhbSBvbkRpZENvbnZlcnRDb21wbGV0aW9uSXRlbSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB7Q29tcGxldGlvbkl0ZW19LCBhbiB7YXRvbSRBdXRvY29tcGxldGVTdWdnZXN0aW9ufVxuICAgKiAgIGFuZCBhIHthdG9tJEF1dG9jb21wbGV0ZVJlcXVlc3R9IGFsbG93aW5nIHlvdSB0byBhZGp1c3QgY29udmVydGVkIGl0ZW1zLlxuICAgKiBAcmV0dXJucyBUaGUge2F0b20kQXV0b2NvbXBsZXRlU3VnZ2VzdGlvbn0gcGFzc2VkIGluIGFzIHN1Z2dlc3Rpb24gd2l0aCB0aGUgY29udmVyc2lvbiBhcHBsaWVkLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBjb21wbGV0aW9uSXRlbVRvU3VnZ2VzdGlvbihcbiAgICBpdGVtOiBDb21wbGV0aW9uSXRlbSxcbiAgICBzdWdnZXN0aW9uOiBTdWdnZXN0aW9uLFxuICAgIHJlcXVlc3Q6IGFjLlN1Z2dlc3Rpb25zUmVxdWVzdGVkRXZlbnQsXG4gICAgdHJpZ2dlckNvbHVtbnM6IFtudW1iZXIsIG51bWJlcl0sXG4gICAgb25EaWRDb252ZXJ0Q29tcGxldGlvbkl0ZW0/OiBDb21wbGV0aW9uSXRlbUFkanVzdGVyLFxuICApOiBTdWdnZXN0aW9uIHtcbiAgICBBdXRvY29tcGxldGVBZGFwdGVyLmFwcGx5Q29tcGxldGlvbkl0ZW1Ub1N1Z2dlc3Rpb24oaXRlbSwgc3VnZ2VzdGlvbiBhcyBUZXh0U3VnZ2VzdGlvbik7XG4gICAgQXV0b2NvbXBsZXRlQWRhcHRlci5hcHBseVRleHRFZGl0VG9TdWdnZXN0aW9uKFxuICAgICAgaXRlbS50ZXh0RWRpdCwgcmVxdWVzdC5lZGl0b3IsIHRyaWdnZXJDb2x1bW5zLCByZXF1ZXN0LmJ1ZmZlclBvc2l0aW9uLCBzdWdnZXN0aW9uIGFzIFRleHRTdWdnZXN0aW9uLFxuICAgICk7XG4gICAgQXV0b2NvbXBsZXRlQWRhcHRlci5hcHBseVNuaXBwZXRUb1N1Z2dlc3Rpb24oaXRlbSwgc3VnZ2VzdGlvbiBhcyBTbmlwcGV0U3VnZ2VzdGlvbik7XG4gICAgaWYgKG9uRGlkQ29udmVydENvbXBsZXRpb25JdGVtICE9IG51bGwpIHtcbiAgICAgIG9uRGlkQ29udmVydENvbXBsZXRpb25JdGVtKGl0ZW0sIHN1Z2dlc3Rpb24gYXMgYWMuQW55U3VnZ2VzdGlvbiwgcmVxdWVzdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1Z2dlc3Rpb247XG4gIH1cblxuICAvKipcbiAgICogUHVibGljOiBDb252ZXJ0IHRoZSBwcmltYXJ5IHBhcnRzIG9mIGEgbGFuZ3VhZ2Ugc2VydmVyIHByb3RvY29sIENvbXBsZXRpb25JdGVtIHRvIGFuIEF1dG9Db21wbGV0ZSsgc3VnZ2VzdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGl0ZW0gQW4ge0NvbXBsZXRpb25JdGVtfSBjb250YWluaW5nIHRoZSBjb21wbGV0aW9uIGl0ZW1zIHRvIGJlIG1lcmdlZCBpbnRvLlxuICAgKiBAcGFyYW0gc3VnZ2VzdGlvbiBUaGUge1N1Z2dlc3Rpb259IHRvIG1lcmdlIHRoZSBjb252ZXJzaW9uIGludG8uXG4gICAqIEByZXR1cm5zIFRoZSB7U3VnZ2VzdGlvbn0gd2l0aCBkZXRhaWxzIGFkZGVkIGZyb20gdGhlIHtDb21wbGV0aW9uSXRlbX0uXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFwcGx5Q29tcGxldGlvbkl0ZW1Ub1N1Z2dlc3Rpb24oXG4gICAgaXRlbTogQ29tcGxldGlvbkl0ZW0sXG4gICAgc3VnZ2VzdGlvbjogVGV4dFN1Z2dlc3Rpb24sXG4gICk6IHZvaWQge1xuICAgIHN1Z2dlc3Rpb24udGV4dCA9IGl0ZW0uaW5zZXJ0VGV4dCB8fCBpdGVtLmxhYmVsO1xuICAgIHN1Z2dlc3Rpb24uZmlsdGVyVGV4dCA9IGl0ZW0uZmlsdGVyVGV4dCB8fCBpdGVtLmxhYmVsO1xuICAgIHN1Z2dlc3Rpb24uZGlzcGxheVRleHQgPSBpdGVtLmxhYmVsO1xuICAgIHN1Z2dlc3Rpb24udHlwZSA9IEF1dG9jb21wbGV0ZUFkYXB0ZXIuY29tcGxldGlvbktpbmRUb1N1Z2dlc3Rpb25UeXBlKGl0ZW0ua2luZCk7XG4gICAgQXV0b2NvbXBsZXRlQWRhcHRlci5hcHBseURldGFpbHNUb1N1Z2dlc3Rpb24oaXRlbSwgc3VnZ2VzdGlvbik7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGFwcGx5RGV0YWlsc1RvU3VnZ2VzdGlvbihcbiAgICBpdGVtOiBDb21wbGV0aW9uSXRlbSxcbiAgICBzdWdnZXN0aW9uOiBTdWdnZXN0aW9uLFxuICApOiB2b2lkIHtcbiAgICBzdWdnZXN0aW9uLnJpZ2h0TGFiZWwgPSBpdGVtLmRldGFpbDtcblxuICAgIC8vIE9sZGVyIGZvcm1hdCwgY2FuJ3Qga25vdyB3aGF0IGl0IGlzIHNvIGFzc2lnbiB0byBib3RoIGFuZCBob3BlIGZvciBiZXN0XG4gICAgaWYgKHR5cGVvZiAoaXRlbS5kb2N1bWVudGF0aW9uKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHN1Z2dlc3Rpb24uZGVzY3JpcHRpb25NYXJrZG93biA9IGl0ZW0uZG9jdW1lbnRhdGlvbjtcbiAgICAgIHN1Z2dlc3Rpb24uZGVzY3JpcHRpb24gPSBpdGVtLmRvY3VtZW50YXRpb247XG4gICAgfVxuXG4gICAgaWYgKGl0ZW0uZG9jdW1lbnRhdGlvbiAhPSBudWxsICYmIHR5cGVvZiAoaXRlbS5kb2N1bWVudGF0aW9uKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIE5ld2VyIGZvcm1hdCBzcGVjaWZpZXMgdGhlIGtpbmQgb2YgZG9jdW1lbnRhdGlvbiwgYXNzaWduIGFwcHJvcHJpYXRlbHlcbiAgICAgIGlmIChpdGVtLmRvY3VtZW50YXRpb24ua2luZCA9PT0gJ21hcmtkb3duJykge1xuICAgICAgICBzdWdnZXN0aW9uLmRlc2NyaXB0aW9uTWFya2Rvd24gPSBpdGVtLmRvY3VtZW50YXRpb24udmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdWdnZXN0aW9uLmRlc2NyaXB0aW9uID0gaXRlbS5kb2N1bWVudGF0aW9uLnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWM6IEFwcGxpZXMgdGhlIHRleHRFZGl0IHBhcnQgb2YgYSBsYW5ndWFnZSBzZXJ2ZXIgcHJvdG9jb2wgQ29tcGxldGlvbkl0ZW0gdG8gYW5cbiAgICogQXV0b0NvbXBsZXRlKyBTdWdnZXN0aW9uIHZpYSB0aGUgcmVwbGFjZW1lbnRQcmVmaXggYW5kIHRleHQgcHJvcGVydGllcy5cbiAgICpcbiAgICogQHBhcmFtIHRleHRFZGl0IEEge1RleHRFZGl0fSBmcm9tIGEgQ29tcGxldGlvbkl0ZW0gdG8gYXBwbHkuXG4gICAqIEBwYXJhbSBlZGl0b3IgQW4gQXRvbSB7VGV4dEVkaXRvcn0gdXNlZCB0byBvYnRhaW4gdGhlIG5lY2Vzc2FyeSB0ZXh0IHJlcGxhY2VtZW50LlxuICAgKiBAcGFyYW0gc3VnZ2VzdGlvbiBBbiB7YXRvbSRBdXRvY29tcGxldGVTdWdnZXN0aW9ufSB0byBzZXQgdGhlIHJlcGxhY2VtZW50UHJlZml4IGFuZCB0ZXh0IHByb3BlcnRpZXMgb2YuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFwcGx5VGV4dEVkaXRUb1N1Z2dlc3Rpb24oXG4gICAgdGV4dEVkaXQ6IFRleHRFZGl0IHwgdW5kZWZpbmVkLFxuICAgIGVkaXRvcjogVGV4dEVkaXRvcixcbiAgICB0cmlnZ2VyQ29sdW1uczogW251bWJlciwgbnVtYmVyXSxcbiAgICBvcmlnaW5hbEJ1ZmZlclBvc2l0aW9uOiBQb2ludCxcbiAgICBzdWdnZXN0aW9uOiBUZXh0U3VnZ2VzdGlvbixcbiAgKTogdm9pZCB7XG4gICAgaWYgKCF0ZXh0RWRpdCkgeyByZXR1cm47IH1cbiAgICBpZiAodGV4dEVkaXQucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyICE9PSB0cmlnZ2VyQ29sdW1uc1swXSkge1xuICAgICAgY29uc3QgcmFuZ2UgPSBDb252ZXJ0LmxzUmFuZ2VUb0F0b21SYW5nZSh0ZXh0RWRpdC5yYW5nZSk7XG4gICAgICBzdWdnZXN0aW9uLmN1c3RvbVJlcGxhY21lbnRQcmVmaXggPSBlZGl0b3IuZ2V0VGV4dEluQnVmZmVyUmFuZ2UoW3JhbmdlLnN0YXJ0LCBvcmlnaW5hbEJ1ZmZlclBvc2l0aW9uXSk7XG4gICAgfVxuICAgIHN1Z2dlc3Rpb24udGV4dCA9IHRleHRFZGl0Lm5ld1RleHQ7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljOiBBZGRzIGEgc25pcHBldCB0byB0aGUgc3VnZ2VzdGlvbiBpZiB0aGUgQ29tcGxldGlvbkl0ZW0gY29udGFpbnNcbiAgICogc25pcHBldC1mb3JtYXR0ZWQgdGV4dFxuICAgKlxuICAgKiBAcGFyYW0gaXRlbSBBbiB7Q29tcGxldGlvbkl0ZW19IGNvbnRhaW5pbmcgdGhlIGNvbXBsZXRpb24gaXRlbXMgdG8gYmUgbWVyZ2VkIGludG8uXG4gICAqIEBwYXJhbSBzdWdnZXN0aW9uIFRoZSB7YXRvbSRBdXRvY29tcGxldGVTdWdnZXN0aW9ufSB0byBtZXJnZSB0aGUgY29udmVyc2lvbiBpbnRvLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhcHBseVNuaXBwZXRUb1N1Z2dlc3Rpb24oaXRlbTogQ29tcGxldGlvbkl0ZW0sIHN1Z2dlc3Rpb246IFNuaXBwZXRTdWdnZXN0aW9uKTogdm9pZCB7XG4gICAgaWYgKGl0ZW0uaW5zZXJ0VGV4dEZvcm1hdCA9PT0gSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0KSB7XG4gICAgICBzdWdnZXN0aW9uLnNuaXBwZXQgPSBpdGVtLnRleHRFZGl0ICE9IG51bGwgPyBpdGVtLnRleHRFZGl0Lm5ld1RleHQgOiAoaXRlbS5pbnNlcnRUZXh0IHx8ICcnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHVibGljOiBPYnRhaW4gdGhlIHRleHR1YWwgc3VnZ2VzdGlvbiB0eXBlIHJlcXVpcmVkIGJ5IEF1dG9Db21wbGV0ZSsgdGhhdFxuICAgKiBtb3N0IGNsb3NlbHkgbWFwcyB0byB0aGUgbnVtZXJpYyBjb21wbGV0aW9uIGtpbmQgc3VwcGxpZXMgYnkgdGhlIGxhbmd1YWdlIHNlcnZlci5cbiAgICpcbiAgICogQHBhcmFtIGtpbmQgQSB7TnVtYmVyfSB0aGF0IHJlcHJlc2VudHMgdGhlIHN1Z2dlc3Rpb24ga2luZCB0byBiZSBjb252ZXJ0ZWQuXG4gICAqIEByZXR1cm5zIEEge1N0cmluZ30gY29udGFpbmluZyB0aGUgQXV0b0NvbXBsZXRlKyBzdWdnZXN0aW9uIHR5cGUgZXF1aXZhbGVudFxuICAgKiAgIHRvIHRoZSBnaXZlbiBjb21wbGV0aW9uIGtpbmQuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGNvbXBsZXRpb25LaW5kVG9TdWdnZXN0aW9uVHlwZShraW5kOiBudW1iZXIgfCB1bmRlZmluZWQpOiBzdHJpbmcge1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBDb21wbGV0aW9uSXRlbUtpbmQuQ29uc3RhbnQ6XG4gICAgICAgIHJldHVybiAnY29uc3RhbnQnO1xuICAgICAgY2FzZSBDb21wbGV0aW9uSXRlbUtpbmQuTWV0aG9kOlxuICAgICAgICByZXR1cm4gJ21ldGhvZCc7XG4gICAgICBjYXNlIENvbXBsZXRpb25JdGVtS2luZC5GdW5jdGlvbjpcbiAgICAgIGNhc2UgQ29tcGxldGlvbkl0ZW1LaW5kLkNvbnN0cnVjdG9yOlxuICAgICAgICByZXR1cm4gJ2Z1bmN0aW9uJztcbiAgICAgIGNhc2UgQ29tcGxldGlvbkl0ZW1LaW5kLkZpZWxkOlxuICAgICAgY2FzZSBDb21wbGV0aW9uSXRlbUtpbmQuUHJvcGVydHk6XG4gICAgICAgIHJldHVybiAncHJvcGVydHknO1xuICAgICAgY2FzZSBDb21wbGV0aW9uSXRlbUtpbmQuVmFyaWFibGU6XG4gICAgICAgIHJldHVybiAndmFyaWFibGUnO1xuICAgICAgY2FzZSBDb21wbGV0aW9uSXRlbUtpbmQuQ2xhc3M6XG4gICAgICAgIHJldHVybiAnY2xhc3MnO1xuICAgICAgY2FzZSBDb21wbGV0aW9uSXRlbUtpbmQuU3RydWN0OlxuICAgICAgY2FzZSBDb21wbGV0aW9uSXRlbUtpbmQuVHlwZVBhcmFtZXRlcjpcbiAgICAgICAgcmV0dXJuICd0eXBlJztcbiAgICAgIGNhc2UgQ29tcGxldGlvbkl0ZW1LaW5kLk9wZXJhdG9yOlxuICAgICAgICByZXR1cm4gJ3NlbGVjdG9yJztcbiAgICAgIGNhc2UgQ29tcGxldGlvbkl0ZW1LaW5kLkludGVyZmFjZTpcbiAgICAgICAgcmV0dXJuICdtaXhpbic7XG4gICAgICBjYXNlIENvbXBsZXRpb25JdGVtS2luZC5Nb2R1bGU6XG4gICAgICAgIHJldHVybiAnbW9kdWxlJztcbiAgICAgIGNhc2UgQ29tcGxldGlvbkl0ZW1LaW5kLlVuaXQ6XG4gICAgICAgIHJldHVybiAnYnVpbHRpbic7XG4gICAgICBjYXNlIENvbXBsZXRpb25JdGVtS2luZC5FbnVtOlxuICAgICAgY2FzZSBDb21wbGV0aW9uSXRlbUtpbmQuRW51bU1lbWJlcjpcbiAgICAgICAgcmV0dXJuICdlbnVtJztcbiAgICAgIGNhc2UgQ29tcGxldGlvbkl0ZW1LaW5kLktleXdvcmQ6XG4gICAgICAgIHJldHVybiAna2V5d29yZCc7XG4gICAgICBjYXNlIENvbXBsZXRpb25JdGVtS2luZC5TbmlwcGV0OlxuICAgICAgICByZXR1cm4gJ3NuaXBwZXQnO1xuICAgICAgY2FzZSBDb21wbGV0aW9uSXRlbUtpbmQuRmlsZTpcbiAgICAgIGNhc2UgQ29tcGxldGlvbkl0ZW1LaW5kLkZvbGRlcjpcbiAgICAgICAgcmV0dXJuICdpbXBvcnQnO1xuICAgICAgY2FzZSBDb21wbGV0aW9uSXRlbUtpbmQuUmVmZXJlbmNlOlxuICAgICAgICByZXR1cm4gJ3JlcXVpcmUnO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICd2YWx1ZSc7XG4gICAgfVxuICB9XG59XG4iXX0=