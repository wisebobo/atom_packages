"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const convert_1 = require("../convert");
/**
 * Public: Adapts the language server protocol "textDocument/completion" to the
 * Atom IDE UI Code-format package.
 */
class CodeFormatAdapter {
    /**
     * Public: Determine whether this adapter can be used to adapt a language server
     * based on the serverCapabilities matrix containing either a documentFormattingProvider
     * or a documentRangeFormattingProvider.
     *
     * @param serverCapabilities The {ServerCapabilities} of the language server to consider.
     * @returns A {Boolean} indicating this adapter can adapt the server based on the
     *   given serverCapabilities.
     */
    static canAdapt(serverCapabilities) {
        return (serverCapabilities.documentRangeFormattingProvider === true ||
            serverCapabilities.documentFormattingProvider === true);
    }
    /**
     * Public: Format text in the editor using the given language server connection and an optional range.
     * If the server does not support range formatting then range will be ignored and the entire document formatted.
     *
     * @param connection A {LanguageClientConnection} to the language server that will format the text.
     * @param serverCapabilities The {ServerCapabilities} of the language server that will be used.
     * @param editor The Atom {TextEditor} containing the text that will be formatted.
     * @param range The optional Atom {Range} containing the subset of the text to be formatted.
     * @returns A {Promise} of an {Array} of {Object}s containing the AutoComplete+
     *   suggestions to display.
     */
    static format(connection, serverCapabilities, editor, range) {
        if (serverCapabilities.documentRangeFormattingProvider) {
            return CodeFormatAdapter.formatRange(connection, editor, range);
        }
        if (serverCapabilities.documentFormattingProvider) {
            return CodeFormatAdapter.formatDocument(connection, editor);
        }
        throw new Error('Can not format document, language server does not support it');
    }
    /**
     * Public: Format the entire document of an Atom {TextEditor} by using a given language server.
     *
     * @param connection A {LanguageClientConnection} to the language server that will format the text.
     * @param editor The Atom {TextEditor} containing the document to be formatted.
     * @returns A {Promise} of an {Array} of {TextEdit} objects that can be applied to the Atom TextEditor
     *   to format the document.
     */
    static formatDocument(connection, editor) {
        return __awaiter(this, void 0, void 0, function* () {
            const edits = yield connection.documentFormatting(CodeFormatAdapter.createDocumentFormattingParams(editor));
            return convert_1.default.convertLsTextEdits(edits);
        });
    }
    /**
     * Public: Create {DocumentFormattingParams} to be sent to the language server when requesting an
     * entire document is formatted.
     *
     * @param editor The Atom {TextEditor} containing the document to be formatted.
     * @returns A {DocumentFormattingParams} containing the identity of the text document as well as
     *   options to be used in formatting the document such as tab size and tabs vs spaces.
     */
    static createDocumentFormattingParams(editor) {
        return {
            textDocument: convert_1.default.editorToTextDocumentIdentifier(editor),
            options: CodeFormatAdapter.getFormatOptions(editor),
        };
    }
    /**
     * Public: Format a range within an Atom {TextEditor} by using a given language server.
     *
     * @param connection A {LanguageClientConnection} to the language server that will format the text.
     * @param range The Atom {Range} containing the range of text that should be formatted.
     * @param editor The Atom {TextEditor} containing the document to be formatted.
     * @returns A {Promise} of an {Array} of {TextEdit} objects that can be applied to the Atom TextEditor
     *   to format the document.
     */
    static formatRange(connection, editor, range) {
        return __awaiter(this, void 0, void 0, function* () {
            const edits = yield connection.documentRangeFormatting(CodeFormatAdapter.createDocumentRangeFormattingParams(editor, range));
            return convert_1.default.convertLsTextEdits(edits);
        });
    }
    /**
     * Public: Create {DocumentRangeFormattingParams} to be sent to the language server when requesting an
     * entire document is formatted.
     *
     * @param editor The Atom {TextEditor} containing the document to be formatted.
     * @param range The Atom {Range} containing the range of text that should be formatted.
     * @returns A {DocumentRangeFormattingParams} containing the identity of the text document, the
     *   range of the text to be formatted as well as the options to be used in formatting the
     *   document such as tab size and tabs vs spaces.
     */
    static createDocumentRangeFormattingParams(editor, range) {
        return {
            textDocument: convert_1.default.editorToTextDocumentIdentifier(editor),
            range: convert_1.default.atomRangeToLSRange(range),
            options: CodeFormatAdapter.getFormatOptions(editor),
        };
    }
    /**
     * Public: Format on type within an Atom {TextEditor} by using a given language server.
     *
     * @param connection A {LanguageClientConnection} to the language server that will format the text.
     * @param editor The Atom {TextEditor} containing the document to be formatted.
     * @param point The {Point} at which the document to be formatted.
     * @param character A character that triggered formatting request.
     * @returns A {Promise} of an {Array} of {TextEdit} objects that can be applied to the Atom TextEditor
     *   to format the document.
     */
    static formatOnType(connection, editor, point, character) {
        return __awaiter(this, void 0, void 0, function* () {
            const edits = yield connection.documentOnTypeFormatting(CodeFormatAdapter.createDocumentOnTypeFormattingParams(editor, point, character));
            return convert_1.default.convertLsTextEdits(edits);
        });
    }
    /**
     * Public: Create {DocumentOnTypeFormattingParams} to be sent to the language server when requesting an
     * entire document is formatted.
     *
     * @param editor The Atom {TextEditor} containing the document to be formatted.
     * @param point The {Point} at which the document to be formatted.
     * @param character A character that triggered formatting request.
     * @returns A {DocumentOnTypeFormattingParams} containing the identity of the text document, the
     *   position of the text to be formatted, the character that triggered formatting request
     *   as well as the options to be used in formatting the document such as tab size and tabs vs spaces.
     */
    static createDocumentOnTypeFormattingParams(editor, point, character) {
        return {
            textDocument: convert_1.default.editorToTextDocumentIdentifier(editor),
            position: convert_1.default.pointToPosition(point),
            ch: character,
            options: CodeFormatAdapter.getFormatOptions(editor),
        };
    }
    /**
     * Public: Create {DocumentRangeFormattingParams} to be sent to the language server when requesting an
     * entire document is formatted.
     *
     * @param editor The Atom {TextEditor} containing the document to be formatted.
     * @param range The Atom {Range} containing the range of document that should be formatted.
     * @returns The {FormattingOptions} to be used containing the keys:
     *   * `tabSize` The number of spaces a tab represents.
     *   * `insertSpaces` {True} if spaces should be used, {False} for tab characters.
     */
    static getFormatOptions(editor) {
        return {
            tabSize: editor.getTabLength(),
            insertSpaces: editor.getSoftTabs(),
        };
    }
}
exports.default = CodeFormatAdapter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29kZS1mb3JtYXQtYWRhcHRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9jb2RlLWZvcm1hdC1hZGFwdGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQ0Esd0NBQWlDO0FBZWpDOzs7R0FHRztBQUNILE1BQXFCLGlCQUFpQjtJQUNwQzs7Ozs7Ozs7T0FRRztJQUNJLE1BQU0sQ0FBQyxRQUFRLENBQUMsa0JBQXNDO1FBQzNELE9BQU8sQ0FDTCxrQkFBa0IsQ0FBQywrQkFBK0IsS0FBSyxJQUFJO1lBQzNELGtCQUFrQixDQUFDLDBCQUEwQixLQUFLLElBQUksQ0FDdkQsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7Ozs7OztPQVVHO0lBQ0ksTUFBTSxDQUFDLE1BQU0sQ0FDbEIsVUFBb0MsRUFDcEMsa0JBQXNDLEVBQ3RDLE1BQWtCLEVBQ2xCLEtBQVk7UUFFWixJQUFJLGtCQUFrQixDQUFDLCtCQUErQixFQUFFO1lBQ3RELE9BQU8saUJBQWlCLENBQUMsV0FBVyxDQUFDLFVBQVUsRUFBRSxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7U0FDakU7UUFFRCxJQUFJLGtCQUFrQixDQUFDLDBCQUEwQixFQUFFO1lBQ2pELE9BQU8saUJBQWlCLENBQUMsY0FBYyxDQUFDLFVBQVUsRUFBRSxNQUFNLENBQUMsQ0FBQztTQUM3RDtRQUVELE1BQU0sSUFBSSxLQUFLLENBQUMsOERBQThELENBQUMsQ0FBQztJQUNsRixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNJLE1BQU0sQ0FBTyxjQUFjLENBQ2hDLFVBQW9DLEVBQ3BDLE1BQWtCOztZQUVsQixNQUFNLEtBQUssR0FBRyxNQUFNLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQyxpQkFBaUIsQ0FBQyw4QkFBOEIsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBQzVHLE9BQU8saUJBQU8sQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMzQyxDQUFDO0tBQUE7SUFFRDs7Ozs7OztPQU9HO0lBQ0ksTUFBTSxDQUFDLDhCQUE4QixDQUFDLE1BQWtCO1FBQzdELE9BQU87WUFDTCxZQUFZLEVBQUUsaUJBQU8sQ0FBQyw4QkFBOEIsQ0FBQyxNQUFNLENBQUM7WUFDNUQsT0FBTyxFQUFFLGlCQUFpQixDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQztTQUNwRCxDQUFDO0lBQ0osQ0FBQztJQUVEOzs7Ozs7OztPQVFHO0lBQ0ksTUFBTSxDQUFPLFdBQVcsQ0FDN0IsVUFBb0MsRUFDcEMsTUFBa0IsRUFDbEIsS0FBWTs7WUFFWixNQUFNLEtBQUssR0FBRyxNQUFNLFVBQVUsQ0FBQyx1QkFBdUIsQ0FDcEQsaUJBQWlCLENBQUMsbUNBQW1DLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUNyRSxDQUFDO1lBQ0YsT0FBTyxpQkFBTyxDQUFDLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzNDLENBQUM7S0FBQTtJQUVEOzs7Ozs7Ozs7T0FTRztJQUNJLE1BQU0sQ0FBQyxtQ0FBbUMsQ0FDL0MsTUFBa0IsRUFDbEIsS0FBWTtRQUVaLE9BQU87WUFDTCxZQUFZLEVBQUUsaUJBQU8sQ0FBQyw4QkFBOEIsQ0FBQyxNQUFNLENBQUM7WUFDNUQsS0FBSyxFQUFFLGlCQUFPLENBQUMsa0JBQWtCLENBQUMsS0FBSyxDQUFDO1lBQ3hDLE9BQU8sRUFBRSxpQkFBaUIsQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUM7U0FDcEQsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7Ozs7O09BU0c7SUFDSSxNQUFNLENBQU8sWUFBWSxDQUM5QixVQUFvQyxFQUNwQyxNQUFrQixFQUNsQixLQUFZLEVBQ1osU0FBaUI7O1lBRWpCLE1BQU0sS0FBSyxHQUFHLE1BQU0sVUFBVSxDQUFDLHdCQUF3QixDQUNyRCxpQkFBaUIsQ0FBQyxvQ0FBb0MsQ0FBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLFNBQVMsQ0FBQyxDQUNqRixDQUFDO1lBQ0YsT0FBTyxpQkFBTyxDQUFDLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzNDLENBQUM7S0FBQTtJQUVEOzs7Ozs7Ozs7O09BVUc7SUFDSSxNQUFNLENBQUMsb0NBQW9DLENBQ2hELE1BQWtCLEVBQ2xCLEtBQVksRUFDWixTQUFpQjtRQUVqQixPQUFPO1lBQ0wsWUFBWSxFQUFFLGlCQUFPLENBQUMsOEJBQThCLENBQUMsTUFBTSxDQUFDO1lBQzVELFFBQVEsRUFBRSxpQkFBTyxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUM7WUFDeEMsRUFBRSxFQUFFLFNBQVM7WUFDYixPQUFPLEVBQUUsaUJBQWlCLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDO1NBQ3BELENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ0ksTUFBTSxDQUFDLGdCQUFnQixDQUFDLE1BQWtCO1FBQy9DLE9BQU87WUFDTCxPQUFPLEVBQUUsTUFBTSxDQUFDLFlBQVksRUFBRTtZQUM5QixZQUFZLEVBQUUsTUFBTSxDQUFDLFdBQVcsRUFBRTtTQUNuQyxDQUFDO0lBQ0osQ0FBQztDQUNGO0FBbkxELG9DQW1MQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGF0b21JZGUgZnJvbSAnYXRvbS1pZGUnO1xuaW1wb3J0IENvbnZlcnQgZnJvbSAnLi4vY29udmVydCc7XG5pbXBvcnQge1xuICBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXG4gIERvY3VtZW50Rm9ybWF0dGluZ1BhcmFtcyxcbiAgRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdQYXJhbXMsXG4gIERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1BhcmFtcyxcbiAgRm9ybWF0dGluZ09wdGlvbnMsXG4gIFNlcnZlckNhcGFiaWxpdGllcyxcbn0gZnJvbSAnLi4vbGFuZ3VhZ2VjbGllbnQnO1xuaW1wb3J0IHtcbiAgVGV4dEVkaXRvcixcbiAgUmFuZ2UsXG4gIFBvaW50LFxufSBmcm9tICdhdG9tJztcblxuLyoqXG4gKiBQdWJsaWM6IEFkYXB0cyB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHByb3RvY29sIFwidGV4dERvY3VtZW50L2NvbXBsZXRpb25cIiB0byB0aGVcbiAqIEF0b20gSURFIFVJIENvZGUtZm9ybWF0IHBhY2thZ2UuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvZGVGb3JtYXRBZGFwdGVyIHtcbiAgLyoqXG4gICAqIFB1YmxpYzogRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBhZGFwdGVyIGNhbiBiZSB1c2VkIHRvIGFkYXB0IGEgbGFuZ3VhZ2Ugc2VydmVyXG4gICAqIGJhc2VkIG9uIHRoZSBzZXJ2ZXJDYXBhYmlsaXRpZXMgbWF0cml4IGNvbnRhaW5pbmcgZWl0aGVyIGEgZG9jdW1lbnRGb3JtYXR0aW5nUHJvdmlkZXJcbiAgICogb3IgYSBkb2N1bWVudFJhbmdlRm9ybWF0dGluZ1Byb3ZpZGVyLlxuICAgKlxuICAgKiBAcGFyYW0gc2VydmVyQ2FwYWJpbGl0aWVzIFRoZSB7U2VydmVyQ2FwYWJpbGl0aWVzfSBvZiB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRvIGNvbnNpZGVyLlxuICAgKiBAcmV0dXJucyBBIHtCb29sZWFufSBpbmRpY2F0aW5nIHRoaXMgYWRhcHRlciBjYW4gYWRhcHQgdGhlIHNlcnZlciBiYXNlZCBvbiB0aGVcbiAgICogICBnaXZlbiBzZXJ2ZXJDYXBhYmlsaXRpZXMuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGNhbkFkYXB0KHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChcbiAgICAgIHNlcnZlckNhcGFiaWxpdGllcy5kb2N1bWVudFJhbmdlRm9ybWF0dGluZ1Byb3ZpZGVyID09PSB0cnVlIHx8XG4gICAgICBzZXJ2ZXJDYXBhYmlsaXRpZXMuZG9jdW1lbnRGb3JtYXR0aW5nUHJvdmlkZXIgPT09IHRydWVcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYzogRm9ybWF0IHRleHQgaW4gdGhlIGVkaXRvciB1c2luZyB0aGUgZ2l2ZW4gbGFuZ3VhZ2Ugc2VydmVyIGNvbm5lY3Rpb24gYW5kIGFuIG9wdGlvbmFsIHJhbmdlLlxuICAgKiBJZiB0aGUgc2VydmVyIGRvZXMgbm90IHN1cHBvcnQgcmFuZ2UgZm9ybWF0dGluZyB0aGVuIHJhbmdlIHdpbGwgYmUgaWdub3JlZCBhbmQgdGhlIGVudGlyZSBkb2N1bWVudCBmb3JtYXR0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSBjb25uZWN0aW9uIEEge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbn0gdG8gdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0IHdpbGwgZm9ybWF0IHRoZSB0ZXh0LlxuICAgKiBAcGFyYW0gc2VydmVyQ2FwYWJpbGl0aWVzIFRoZSB7U2VydmVyQ2FwYWJpbGl0aWVzfSBvZiB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRoYXQgd2lsbCBiZSB1c2VkLlxuICAgKiBAcGFyYW0gZWRpdG9yIFRoZSBBdG9tIHtUZXh0RWRpdG9yfSBjb250YWluaW5nIHRoZSB0ZXh0IHRoYXQgd2lsbCBiZSBmb3JtYXR0ZWQuXG4gICAqIEBwYXJhbSByYW5nZSBUaGUgb3B0aW9uYWwgQXRvbSB7UmFuZ2V9IGNvbnRhaW5pbmcgdGhlIHN1YnNldCBvZiB0aGUgdGV4dCB0byBiZSBmb3JtYXR0ZWQuXG4gICAqIEByZXR1cm5zIEEge1Byb21pc2V9IG9mIGFuIHtBcnJheX0gb2Yge09iamVjdH1zIGNvbnRhaW5pbmcgdGhlIEF1dG9Db21wbGV0ZStcbiAgICogICBzdWdnZXN0aW9ucyB0byBkaXNwbGF5LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmb3JtYXQoXG4gICAgY29ubmVjdGlvbjogTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLFxuICAgIHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzLFxuICAgIGVkaXRvcjogVGV4dEVkaXRvcixcbiAgICByYW5nZTogUmFuZ2UsXG4gICk6IFByb21pc2U8YXRvbUlkZS5UZXh0RWRpdFtdPiB7XG4gICAgaWYgKHNlcnZlckNhcGFiaWxpdGllcy5kb2N1bWVudFJhbmdlRm9ybWF0dGluZ1Byb3ZpZGVyKSB7XG4gICAgICByZXR1cm4gQ29kZUZvcm1hdEFkYXB0ZXIuZm9ybWF0UmFuZ2UoY29ubmVjdGlvbiwgZWRpdG9yLCByYW5nZSk7XG4gICAgfVxuXG4gICAgaWYgKHNlcnZlckNhcGFiaWxpdGllcy5kb2N1bWVudEZvcm1hdHRpbmdQcm92aWRlcikge1xuICAgICAgcmV0dXJuIENvZGVGb3JtYXRBZGFwdGVyLmZvcm1hdERvY3VtZW50KGNvbm5lY3Rpb24sIGVkaXRvcik7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGZvcm1hdCBkb2N1bWVudCwgbGFuZ3VhZ2Ugc2VydmVyIGRvZXMgbm90IHN1cHBvcnQgaXQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWM6IEZvcm1hdCB0aGUgZW50aXJlIGRvY3VtZW50IG9mIGFuIEF0b20ge1RleHRFZGl0b3J9IGJ5IHVzaW5nIGEgZ2l2ZW4gbGFuZ3VhZ2Ugc2VydmVyLlxuICAgKlxuICAgKiBAcGFyYW0gY29ubmVjdGlvbiBBIHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb259IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdGhhdCB3aWxsIGZvcm1hdCB0aGUgdGV4dC5cbiAgICogQHBhcmFtIGVkaXRvciBUaGUgQXRvbSB7VGV4dEVkaXRvcn0gY29udGFpbmluZyB0aGUgZG9jdW1lbnQgdG8gYmUgZm9ybWF0dGVkLlxuICAgKiBAcmV0dXJucyBBIHtQcm9taXNlfSBvZiBhbiB7QXJyYXl9IG9mIHtUZXh0RWRpdH0gb2JqZWN0cyB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvIHRoZSBBdG9tIFRleHRFZGl0b3JcbiAgICogICB0byBmb3JtYXQgdGhlIGRvY3VtZW50LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhc3luYyBmb3JtYXREb2N1bWVudChcbiAgICBjb25uZWN0aW9uOiBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXG4gICAgZWRpdG9yOiBUZXh0RWRpdG9yLFxuICApOiBQcm9taXNlPGF0b21JZGUuVGV4dEVkaXRbXT4ge1xuICAgIGNvbnN0IGVkaXRzID0gYXdhaXQgY29ubmVjdGlvbi5kb2N1bWVudEZvcm1hdHRpbmcoQ29kZUZvcm1hdEFkYXB0ZXIuY3JlYXRlRG9jdW1lbnRGb3JtYXR0aW5nUGFyYW1zKGVkaXRvcikpO1xuICAgIHJldHVybiBDb252ZXJ0LmNvbnZlcnRMc1RleHRFZGl0cyhlZGl0cyk7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljOiBDcmVhdGUge0RvY3VtZW50Rm9ybWF0dGluZ1BhcmFtc30gdG8gYmUgc2VudCB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHdoZW4gcmVxdWVzdGluZyBhblxuICAgKiBlbnRpcmUgZG9jdW1lbnQgaXMgZm9ybWF0dGVkLlxuICAgKlxuICAgKiBAcGFyYW0gZWRpdG9yIFRoZSBBdG9tIHtUZXh0RWRpdG9yfSBjb250YWluaW5nIHRoZSBkb2N1bWVudCB0byBiZSBmb3JtYXR0ZWQuXG4gICAqIEByZXR1cm5zIEEge0RvY3VtZW50Rm9ybWF0dGluZ1BhcmFtc30gY29udGFpbmluZyB0aGUgaWRlbnRpdHkgb2YgdGhlIHRleHQgZG9jdW1lbnQgYXMgd2VsbCBhc1xuICAgKiAgIG9wdGlvbnMgdG8gYmUgdXNlZCBpbiBmb3JtYXR0aW5nIHRoZSBkb2N1bWVudCBzdWNoIGFzIHRhYiBzaXplIGFuZCB0YWJzIHZzIHNwYWNlcy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlRG9jdW1lbnRGb3JtYXR0aW5nUGFyYW1zKGVkaXRvcjogVGV4dEVkaXRvcik6IERvY3VtZW50Rm9ybWF0dGluZ1BhcmFtcyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHREb2N1bWVudDogQ29udmVydC5lZGl0b3JUb1RleHREb2N1bWVudElkZW50aWZpZXIoZWRpdG9yKSxcbiAgICAgIG9wdGlvbnM6IENvZGVGb3JtYXRBZGFwdGVyLmdldEZvcm1hdE9wdGlvbnMoZWRpdG9yKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYzogRm9ybWF0IGEgcmFuZ2Ugd2l0aGluIGFuIEF0b20ge1RleHRFZGl0b3J9IGJ5IHVzaW5nIGEgZ2l2ZW4gbGFuZ3VhZ2Ugc2VydmVyLlxuICAgKlxuICAgKiBAcGFyYW0gY29ubmVjdGlvbiBBIHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb259IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdGhhdCB3aWxsIGZvcm1hdCB0aGUgdGV4dC5cbiAgICogQHBhcmFtIHJhbmdlIFRoZSBBdG9tIHtSYW5nZX0gY29udGFpbmluZyB0aGUgcmFuZ2Ugb2YgdGV4dCB0aGF0IHNob3VsZCBiZSBmb3JtYXR0ZWQuXG4gICAqIEBwYXJhbSBlZGl0b3IgVGhlIEF0b20ge1RleHRFZGl0b3J9IGNvbnRhaW5pbmcgdGhlIGRvY3VtZW50IHRvIGJlIGZvcm1hdHRlZC5cbiAgICogQHJldHVybnMgQSB7UHJvbWlzZX0gb2YgYW4ge0FycmF5fSBvZiB7VGV4dEVkaXR9IG9iamVjdHMgdGhhdCBjYW4gYmUgYXBwbGllZCB0byB0aGUgQXRvbSBUZXh0RWRpdG9yXG4gICAqICAgdG8gZm9ybWF0IHRoZSBkb2N1bWVudC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgZm9ybWF0UmFuZ2UoXG4gICAgY29ubmVjdGlvbjogTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLFxuICAgIGVkaXRvcjogVGV4dEVkaXRvcixcbiAgICByYW5nZTogUmFuZ2UsXG4gICk6IFByb21pc2U8YXRvbUlkZS5UZXh0RWRpdFtdPiB7XG4gICAgY29uc3QgZWRpdHMgPSBhd2FpdCBjb25uZWN0aW9uLmRvY3VtZW50UmFuZ2VGb3JtYXR0aW5nKFxuICAgICAgQ29kZUZvcm1hdEFkYXB0ZXIuY3JlYXRlRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdQYXJhbXMoZWRpdG9yLCByYW5nZSksXG4gICAgKTtcbiAgICByZXR1cm4gQ29udmVydC5jb252ZXJ0THNUZXh0RWRpdHMoZWRpdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYzogQ3JlYXRlIHtEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1BhcmFtc30gdG8gYmUgc2VudCB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHdoZW4gcmVxdWVzdGluZyBhblxuICAgKiBlbnRpcmUgZG9jdW1lbnQgaXMgZm9ybWF0dGVkLlxuICAgKlxuICAgKiBAcGFyYW0gZWRpdG9yIFRoZSBBdG9tIHtUZXh0RWRpdG9yfSBjb250YWluaW5nIHRoZSBkb2N1bWVudCB0byBiZSBmb3JtYXR0ZWQuXG4gICAqIEBwYXJhbSByYW5nZSBUaGUgQXRvbSB7UmFuZ2V9IGNvbnRhaW5pbmcgdGhlIHJhbmdlIG9mIHRleHQgdGhhdCBzaG91bGQgYmUgZm9ybWF0dGVkLlxuICAgKiBAcmV0dXJucyBBIHtEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1BhcmFtc30gY29udGFpbmluZyB0aGUgaWRlbnRpdHkgb2YgdGhlIHRleHQgZG9jdW1lbnQsIHRoZVxuICAgKiAgIHJhbmdlIG9mIHRoZSB0ZXh0IHRvIGJlIGZvcm1hdHRlZCBhcyB3ZWxsIGFzIHRoZSBvcHRpb25zIHRvIGJlIHVzZWQgaW4gZm9ybWF0dGluZyB0aGVcbiAgICogICBkb2N1bWVudCBzdWNoIGFzIHRhYiBzaXplIGFuZCB0YWJzIHZzIHNwYWNlcy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdQYXJhbXMoXG4gICAgZWRpdG9yOiBUZXh0RWRpdG9yLFxuICAgIHJhbmdlOiBSYW5nZSxcbiAgKTogRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdQYXJhbXMge1xuICAgIHJldHVybiB7XG4gICAgICB0ZXh0RG9jdW1lbnQ6IENvbnZlcnQuZWRpdG9yVG9UZXh0RG9jdW1lbnRJZGVudGlmaWVyKGVkaXRvciksXG4gICAgICByYW5nZTogQ29udmVydC5hdG9tUmFuZ2VUb0xTUmFuZ2UocmFuZ2UpLFxuICAgICAgb3B0aW9uczogQ29kZUZvcm1hdEFkYXB0ZXIuZ2V0Rm9ybWF0T3B0aW9ucyhlZGl0b3IpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUHVibGljOiBGb3JtYXQgb24gdHlwZSB3aXRoaW4gYW4gQXRvbSB7VGV4dEVkaXRvcn0gYnkgdXNpbmcgYSBnaXZlbiBsYW5ndWFnZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEBwYXJhbSBjb25uZWN0aW9uIEEge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbn0gdG8gdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0IHdpbGwgZm9ybWF0IHRoZSB0ZXh0LlxuICAgKiBAcGFyYW0gZWRpdG9yIFRoZSBBdG9tIHtUZXh0RWRpdG9yfSBjb250YWluaW5nIHRoZSBkb2N1bWVudCB0byBiZSBmb3JtYXR0ZWQuXG4gICAqIEBwYXJhbSBwb2ludCBUaGUge1BvaW50fSBhdCB3aGljaCB0aGUgZG9jdW1lbnQgdG8gYmUgZm9ybWF0dGVkLlxuICAgKiBAcGFyYW0gY2hhcmFjdGVyIEEgY2hhcmFjdGVyIHRoYXQgdHJpZ2dlcmVkIGZvcm1hdHRpbmcgcmVxdWVzdC5cbiAgICogQHJldHVybnMgQSB7UHJvbWlzZX0gb2YgYW4ge0FycmF5fSBvZiB7VGV4dEVkaXR9IG9iamVjdHMgdGhhdCBjYW4gYmUgYXBwbGllZCB0byB0aGUgQXRvbSBUZXh0RWRpdG9yXG4gICAqICAgdG8gZm9ybWF0IHRoZSBkb2N1bWVudC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgZm9ybWF0T25UeXBlKFxuICAgIGNvbm5lY3Rpb246IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcbiAgICBlZGl0b3I6IFRleHRFZGl0b3IsXG4gICAgcG9pbnQ6IFBvaW50LFxuICAgIGNoYXJhY3Rlcjogc3RyaW5nLFxuICApOiBQcm9taXNlPGF0b21JZGUuVGV4dEVkaXRbXT4ge1xuICAgIGNvbnN0IGVkaXRzID0gYXdhaXQgY29ubmVjdGlvbi5kb2N1bWVudE9uVHlwZUZvcm1hdHRpbmcoXG4gICAgICBDb2RlRm9ybWF0QWRhcHRlci5jcmVhdGVEb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdQYXJhbXMoZWRpdG9yLCBwb2ludCwgY2hhcmFjdGVyKSxcbiAgICApO1xuICAgIHJldHVybiBDb252ZXJ0LmNvbnZlcnRMc1RleHRFZGl0cyhlZGl0cyk7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljOiBDcmVhdGUge0RvY3VtZW50T25UeXBlRm9ybWF0dGluZ1BhcmFtc30gdG8gYmUgc2VudCB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHdoZW4gcmVxdWVzdGluZyBhblxuICAgKiBlbnRpcmUgZG9jdW1lbnQgaXMgZm9ybWF0dGVkLlxuICAgKlxuICAgKiBAcGFyYW0gZWRpdG9yIFRoZSBBdG9tIHtUZXh0RWRpdG9yfSBjb250YWluaW5nIHRoZSBkb2N1bWVudCB0byBiZSBmb3JtYXR0ZWQuXG4gICAqIEBwYXJhbSBwb2ludCBUaGUge1BvaW50fSBhdCB3aGljaCB0aGUgZG9jdW1lbnQgdG8gYmUgZm9ybWF0dGVkLlxuICAgKiBAcGFyYW0gY2hhcmFjdGVyIEEgY2hhcmFjdGVyIHRoYXQgdHJpZ2dlcmVkIGZvcm1hdHRpbmcgcmVxdWVzdC5cbiAgICogQHJldHVybnMgQSB7RG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUGFyYW1zfSBjb250YWluaW5nIHRoZSBpZGVudGl0eSBvZiB0aGUgdGV4dCBkb2N1bWVudCwgdGhlXG4gICAqICAgcG9zaXRpb24gb2YgdGhlIHRleHQgdG8gYmUgZm9ybWF0dGVkLCB0aGUgY2hhcmFjdGVyIHRoYXQgdHJpZ2dlcmVkIGZvcm1hdHRpbmcgcmVxdWVzdFxuICAgKiAgIGFzIHdlbGwgYXMgdGhlIG9wdGlvbnMgdG8gYmUgdXNlZCBpbiBmb3JtYXR0aW5nIHRoZSBkb2N1bWVudCBzdWNoIGFzIHRhYiBzaXplIGFuZCB0YWJzIHZzIHNwYWNlcy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUGFyYW1zKFxuICAgIGVkaXRvcjogVGV4dEVkaXRvcixcbiAgICBwb2ludDogUG9pbnQsXG4gICAgY2hhcmFjdGVyOiBzdHJpbmcsXG4gICk6IERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1BhcmFtcyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHREb2N1bWVudDogQ29udmVydC5lZGl0b3JUb1RleHREb2N1bWVudElkZW50aWZpZXIoZWRpdG9yKSxcbiAgICAgIHBvc2l0aW9uOiBDb252ZXJ0LnBvaW50VG9Qb3NpdGlvbihwb2ludCksXG4gICAgICBjaDogY2hhcmFjdGVyLFxuICAgICAgb3B0aW9uczogQ29kZUZvcm1hdEFkYXB0ZXIuZ2V0Rm9ybWF0T3B0aW9ucyhlZGl0b3IpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUHVibGljOiBDcmVhdGUge0RvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUGFyYW1zfSB0byBiZSBzZW50IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgd2hlbiByZXF1ZXN0aW5nIGFuXG4gICAqIGVudGlyZSBkb2N1bWVudCBpcyBmb3JtYXR0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSBlZGl0b3IgVGhlIEF0b20ge1RleHRFZGl0b3J9IGNvbnRhaW5pbmcgdGhlIGRvY3VtZW50IHRvIGJlIGZvcm1hdHRlZC5cbiAgICogQHBhcmFtIHJhbmdlIFRoZSBBdG9tIHtSYW5nZX0gY29udGFpbmluZyB0aGUgcmFuZ2Ugb2YgZG9jdW1lbnQgdGhhdCBzaG91bGQgYmUgZm9ybWF0dGVkLlxuICAgKiBAcmV0dXJucyBUaGUge0Zvcm1hdHRpbmdPcHRpb25zfSB0byBiZSB1c2VkIGNvbnRhaW5pbmcgdGhlIGtleXM6XG4gICAqICAgKiBgdGFiU2l6ZWAgVGhlIG51bWJlciBvZiBzcGFjZXMgYSB0YWIgcmVwcmVzZW50cy5cbiAgICogICAqIGBpbnNlcnRTcGFjZXNgIHtUcnVlfSBpZiBzcGFjZXMgc2hvdWxkIGJlIHVzZWQsIHtGYWxzZX0gZm9yIHRhYiBjaGFyYWN0ZXJzLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBnZXRGb3JtYXRPcHRpb25zKGVkaXRvcjogVGV4dEVkaXRvcik6IEZvcm1hdHRpbmdPcHRpb25zIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGFiU2l6ZTogZWRpdG9yLmdldFRhYkxlbmd0aCgpLFxuICAgICAgaW5zZXJ0U3BhY2VzOiBlZGl0b3IuZ2V0U29mdFRhYnMoKSxcbiAgICB9O1xuICB9XG59XG4iXX0=