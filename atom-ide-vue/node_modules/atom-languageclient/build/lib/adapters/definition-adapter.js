"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const convert_1 = require("../convert");
const Utils = require("../utils");
const atom_1 = require("atom");
/**
 * Public: Adapts the language server definition provider to the
 * Atom IDE UI Definitions package for 'Go To Definition' functionality.
 */
class DefinitionAdapter {
    /**
     * Public: Determine whether this adapter can be used to adapt a language server
     * based on the serverCapabilities matrix containing a definitionProvider.
     *
     * @param serverCapabilities The {ServerCapabilities} of the language server to consider.
     * @returns A {Boolean} indicating adapter can adapt the server based on the
     *   given serverCapabilities.
     */
    static canAdapt(serverCapabilities) {
        return serverCapabilities.definitionProvider === true;
    }
    /**
     * Public: Get the definitions for a symbol at a given {Point} within a
     * {TextEditor} including optionally highlighting all other references
     * within the document if the langauge server also supports highlighting.
     *
     * @param connection A {LanguageClientConnection} to the language server that will provide definitions and highlights.
     * @param serverCapabilities The {ServerCapabilities} of the language server that will be used.
     * @param languageName The name of the programming language.
     * @param editor The Atom {TextEditor} containing the symbol and potential highlights.
     * @param point The Atom {Point} containing the position of the text that represents the symbol
     *   for which the definition and highlights should be provided.
     * @returns A {Promise} indicating adapter can adapt the server based on the
     *   given serverCapabilities.
     */
    getDefinition(connection, serverCapabilities, languageName, editor, point) {
        return __awaiter(this, void 0, void 0, function* () {
            const documentPositionParams = convert_1.default.editorToTextDocumentPositionParams(editor, point);
            const definitionLocations = DefinitionAdapter.normalizeLocations(yield connection.gotoDefinition(documentPositionParams));
            if (definitionLocations == null || definitionLocations.length === 0) {
                return null;
            }
            let queryRange;
            if (serverCapabilities.documentHighlightProvider) {
                const highlights = yield connection.documentHighlight(documentPositionParams);
                if (highlights != null && highlights.length > 0) {
                    queryRange = highlights.map((h) => convert_1.default.lsRangeToAtomRange(h.range));
                }
            }
            return {
                queryRange: queryRange || [Utils.getWordAtPosition(editor, point)],
                definitions: DefinitionAdapter.convertLocationsToDefinitions(definitionLocations, languageName),
            };
        });
    }
    /**
     * Public: Normalize the locations so a single {Location} becomes an {Array} of just
     * one. The language server protocol return either as the protocol evolved between v1 and v2.
     *
     * @param locationResult Either a single {Location} object or an {Array} of {Locations}.
     * @returns An {Array} of {Location}s or {null} if the locationResult was null.
     */
    static normalizeLocations(locationResult) {
        if (locationResult == null) {
            return null;
        }
        return (Array.isArray(locationResult) ? locationResult : [locationResult]).filter((d) => d.range.start != null);
    }
    /**
     * Public: Convert an {Array} of {Location} objects into an Array of {Definition}s.
     *
     * @param locations An {Array} of {Location} objects to be converted.
     * @param languageName The name of the language these objects are written in.
     * @returns An {Array} of {Definition}s that represented the converted {Location}s.
     */
    static convertLocationsToDefinitions(locations, languageName) {
        return locations.map((d) => ({
            path: convert_1.default.uriToPath(d.uri),
            position: convert_1.default.positionToPoint(d.range.start),
            range: atom_1.Range.fromObject(convert_1.default.lsRangeToAtomRange(d.range)),
            language: languageName,
        }));
    }
}
exports.default = DefinitionAdapter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVmaW5pdGlvbi1hZGFwdGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbGliL2FkYXB0ZXJzL2RlZmluaXRpb24tYWRhcHRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUNBLHdDQUFpQztBQUNqQyxrQ0FBa0M7QUFNbEMsK0JBSWM7QUFFZDs7O0dBR0c7QUFDSCxNQUFxQixpQkFBaUI7SUFDcEM7Ozs7Ozs7T0FPRztJQUNJLE1BQU0sQ0FBQyxRQUFRLENBQUMsa0JBQXNDO1FBQzNELE9BQU8sa0JBQWtCLENBQUMsa0JBQWtCLEtBQUssSUFBSSxDQUFDO0lBQ3hELENBQUM7SUFFRDs7Ozs7Ozs7Ozs7OztPQWFHO0lBQ1UsYUFBYSxDQUN4QixVQUFvQyxFQUNwQyxrQkFBc0MsRUFDdEMsWUFBb0IsRUFDcEIsTUFBa0IsRUFDbEIsS0FBWTs7WUFFWixNQUFNLHNCQUFzQixHQUFHLGlCQUFPLENBQUMsa0NBQWtDLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQ3pGLE1BQU0sbUJBQW1CLEdBQUcsaUJBQWlCLENBQUMsa0JBQWtCLENBQzlELE1BQU0sVUFBVSxDQUFDLGNBQWMsQ0FBQyxzQkFBc0IsQ0FBQyxDQUN4RCxDQUFDO1lBQ0YsSUFBSSxtQkFBbUIsSUFBSSxJQUFJLElBQUksbUJBQW1CLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtnQkFDbkUsT0FBTyxJQUFJLENBQUM7YUFDYjtZQUVELElBQUksVUFBVSxDQUFDO1lBQ2YsSUFBSSxrQkFBa0IsQ0FBQyx5QkFBeUIsRUFBRTtnQkFDaEQsTUFBTSxVQUFVLEdBQUcsTUFBTSxVQUFVLENBQUMsaUJBQWlCLENBQUMsc0JBQXNCLENBQUMsQ0FBQztnQkFDOUUsSUFBSSxVQUFVLElBQUksSUFBSSxJQUFJLFVBQVUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO29CQUMvQyxVQUFVLEdBQUcsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsaUJBQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztpQkFDekU7YUFDRjtZQUVELE9BQU87Z0JBQ0wsVUFBVSxFQUFFLFVBQVUsSUFBSSxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7Z0JBQ2xFLFdBQVcsRUFBRSxpQkFBaUIsQ0FBQyw2QkFBNkIsQ0FBQyxtQkFBbUIsRUFBRSxZQUFZLENBQUM7YUFDaEcsQ0FBQztRQUNKLENBQUM7S0FBQTtJQUVEOzs7Ozs7T0FNRztJQUNJLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxjQUFxQztRQUNwRSxJQUFJLGNBQWMsSUFBSSxJQUFJLEVBQUU7WUFDMUIsT0FBTyxJQUFJLENBQUM7U0FDYjtRQUNELE9BQU8sQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxDQUFDO0lBQ2xILENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxNQUFNLENBQUMsNkJBQTZCLENBQUMsU0FBcUIsRUFBRSxZQUFvQjtRQUNyRixPQUFPLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDM0IsSUFBSSxFQUFFLGlCQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7WUFDOUIsUUFBUSxFQUFFLGlCQUFPLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDO1lBQ2hELEtBQUssRUFBRSxZQUFLLENBQUMsVUFBVSxDQUFDLGlCQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzVELFFBQVEsRUFBRSxZQUFZO1NBQ3ZCLENBQUMsQ0FBQyxDQUFDO0lBQ04sQ0FBQztDQUNGO0FBckZELG9DQXFGQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGF0b21JZGUgZnJvbSAnYXRvbS1pZGUnO1xuaW1wb3J0IENvbnZlcnQgZnJvbSAnLi4vY29udmVydCc7XG5pbXBvcnQgKiBhcyBVdGlscyBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQge1xuICBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXG4gIExvY2F0aW9uLFxuICBTZXJ2ZXJDYXBhYmlsaXRpZXMsXG59IGZyb20gJy4uL2xhbmd1YWdlY2xpZW50JztcbmltcG9ydCB7XG4gIFBvaW50LFxuICBUZXh0RWRpdG9yLFxuICBSYW5nZSxcbn0gZnJvbSAnYXRvbSc7XG5cbi8qKlxuICogUHVibGljOiBBZGFwdHMgdGhlIGxhbmd1YWdlIHNlcnZlciBkZWZpbml0aW9uIHByb3ZpZGVyIHRvIHRoZVxuICogQXRvbSBJREUgVUkgRGVmaW5pdGlvbnMgcGFja2FnZSBmb3IgJ0dvIFRvIERlZmluaXRpb24nIGZ1bmN0aW9uYWxpdHkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlZmluaXRpb25BZGFwdGVyIHtcbiAgLyoqXG4gICAqIFB1YmxpYzogRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBhZGFwdGVyIGNhbiBiZSB1c2VkIHRvIGFkYXB0IGEgbGFuZ3VhZ2Ugc2VydmVyXG4gICAqIGJhc2VkIG9uIHRoZSBzZXJ2ZXJDYXBhYmlsaXRpZXMgbWF0cml4IGNvbnRhaW5pbmcgYSBkZWZpbml0aW9uUHJvdmlkZXIuXG4gICAqXG4gICAqIEBwYXJhbSBzZXJ2ZXJDYXBhYmlsaXRpZXMgVGhlIHtTZXJ2ZXJDYXBhYmlsaXRpZXN9IG9mIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdG8gY29uc2lkZXIuXG4gICAqIEByZXR1cm5zIEEge0Jvb2xlYW59IGluZGljYXRpbmcgYWRhcHRlciBjYW4gYWRhcHQgdGhlIHNlcnZlciBiYXNlZCBvbiB0aGVcbiAgICogICBnaXZlbiBzZXJ2ZXJDYXBhYmlsaXRpZXMuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGNhbkFkYXB0KHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHNlcnZlckNhcGFiaWxpdGllcy5kZWZpbml0aW9uUHJvdmlkZXIgPT09IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljOiBHZXQgdGhlIGRlZmluaXRpb25zIGZvciBhIHN5bWJvbCBhdCBhIGdpdmVuIHtQb2ludH0gd2l0aGluIGFcbiAgICoge1RleHRFZGl0b3J9IGluY2x1ZGluZyBvcHRpb25hbGx5IGhpZ2hsaWdodGluZyBhbGwgb3RoZXIgcmVmZXJlbmNlc1xuICAgKiB3aXRoaW4gdGhlIGRvY3VtZW50IGlmIHRoZSBsYW5nYXVnZSBzZXJ2ZXIgYWxzbyBzdXBwb3J0cyBoaWdobGlnaHRpbmcuXG4gICAqXG4gICAqIEBwYXJhbSBjb25uZWN0aW9uIEEge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbn0gdG8gdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0IHdpbGwgcHJvdmlkZSBkZWZpbml0aW9ucyBhbmQgaGlnaGxpZ2h0cy5cbiAgICogQHBhcmFtIHNlcnZlckNhcGFiaWxpdGllcyBUaGUge1NlcnZlckNhcGFiaWxpdGllc30gb2YgdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0IHdpbGwgYmUgdXNlZC5cbiAgICogQHBhcmFtIGxhbmd1YWdlTmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2UuXG4gICAqIEBwYXJhbSBlZGl0b3IgVGhlIEF0b20ge1RleHRFZGl0b3J9IGNvbnRhaW5pbmcgdGhlIHN5bWJvbCBhbmQgcG90ZW50aWFsIGhpZ2hsaWdodHMuXG4gICAqIEBwYXJhbSBwb2ludCBUaGUgQXRvbSB7UG9pbnR9IGNvbnRhaW5pbmcgdGhlIHBvc2l0aW9uIG9mIHRoZSB0ZXh0IHRoYXQgcmVwcmVzZW50cyB0aGUgc3ltYm9sXG4gICAqICAgZm9yIHdoaWNoIHRoZSBkZWZpbml0aW9uIGFuZCBoaWdobGlnaHRzIHNob3VsZCBiZSBwcm92aWRlZC5cbiAgICogQHJldHVybnMgQSB7UHJvbWlzZX0gaW5kaWNhdGluZyBhZGFwdGVyIGNhbiBhZGFwdCB0aGUgc2VydmVyIGJhc2VkIG9uIHRoZVxuICAgKiAgIGdpdmVuIHNlcnZlckNhcGFiaWxpdGllcy5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBnZXREZWZpbml0aW9uKFxuICAgIGNvbm5lY3Rpb246IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcbiAgICBzZXJ2ZXJDYXBhYmlsaXRpZXM6IFNlcnZlckNhcGFiaWxpdGllcyxcbiAgICBsYW5ndWFnZU5hbWU6IHN0cmluZyxcbiAgICBlZGl0b3I6IFRleHRFZGl0b3IsXG4gICAgcG9pbnQ6IFBvaW50LFxuICApOiBQcm9taXNlPGF0b21JZGUuRGVmaW5pdGlvblF1ZXJ5UmVzdWx0IHwgbnVsbD4ge1xuICAgIGNvbnN0IGRvY3VtZW50UG9zaXRpb25QYXJhbXMgPSBDb252ZXJ0LmVkaXRvclRvVGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXMoZWRpdG9yLCBwb2ludCk7XG4gICAgY29uc3QgZGVmaW5pdGlvbkxvY2F0aW9ucyA9IERlZmluaXRpb25BZGFwdGVyLm5vcm1hbGl6ZUxvY2F0aW9ucyhcbiAgICAgIGF3YWl0IGNvbm5lY3Rpb24uZ290b0RlZmluaXRpb24oZG9jdW1lbnRQb3NpdGlvblBhcmFtcyksXG4gICAgKTtcbiAgICBpZiAoZGVmaW5pdGlvbkxvY2F0aW9ucyA9PSBudWxsIHx8IGRlZmluaXRpb25Mb2NhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgcXVlcnlSYW5nZTtcbiAgICBpZiAoc2VydmVyQ2FwYWJpbGl0aWVzLmRvY3VtZW50SGlnaGxpZ2h0UHJvdmlkZXIpIHtcbiAgICAgIGNvbnN0IGhpZ2hsaWdodHMgPSBhd2FpdCBjb25uZWN0aW9uLmRvY3VtZW50SGlnaGxpZ2h0KGRvY3VtZW50UG9zaXRpb25QYXJhbXMpO1xuICAgICAgaWYgKGhpZ2hsaWdodHMgIT0gbnVsbCAmJiBoaWdobGlnaHRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcXVlcnlSYW5nZSA9IGhpZ2hsaWdodHMubWFwKChoKSA9PiBDb252ZXJ0LmxzUmFuZ2VUb0F0b21SYW5nZShoLnJhbmdlKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHF1ZXJ5UmFuZ2U6IHF1ZXJ5UmFuZ2UgfHwgW1V0aWxzLmdldFdvcmRBdFBvc2l0aW9uKGVkaXRvciwgcG9pbnQpXSxcbiAgICAgIGRlZmluaXRpb25zOiBEZWZpbml0aW9uQWRhcHRlci5jb252ZXJ0TG9jYXRpb25zVG9EZWZpbml0aW9ucyhkZWZpbml0aW9uTG9jYXRpb25zLCBsYW5ndWFnZU5hbWUpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUHVibGljOiBOb3JtYWxpemUgdGhlIGxvY2F0aW9ucyBzbyBhIHNpbmdsZSB7TG9jYXRpb259IGJlY29tZXMgYW4ge0FycmF5fSBvZiBqdXN0XG4gICAqIG9uZS4gVGhlIGxhbmd1YWdlIHNlcnZlciBwcm90b2NvbCByZXR1cm4gZWl0aGVyIGFzIHRoZSBwcm90b2NvbCBldm9sdmVkIGJldHdlZW4gdjEgYW5kIHYyLlxuICAgKlxuICAgKiBAcGFyYW0gbG9jYXRpb25SZXN1bHQgRWl0aGVyIGEgc2luZ2xlIHtMb2NhdGlvbn0gb2JqZWN0IG9yIGFuIHtBcnJheX0gb2Yge0xvY2F0aW9uc30uXG4gICAqIEByZXR1cm5zIEFuIHtBcnJheX0gb2Yge0xvY2F0aW9ufXMgb3Ige251bGx9IGlmIHRoZSBsb2NhdGlvblJlc3VsdCB3YXMgbnVsbC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbm9ybWFsaXplTG9jYXRpb25zKGxvY2F0aW9uUmVzdWx0OiBMb2NhdGlvbiB8IExvY2F0aW9uW10pOiBMb2NhdGlvbltdIHwgbnVsbCB7XG4gICAgaWYgKGxvY2F0aW9uUmVzdWx0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkobG9jYXRpb25SZXN1bHQpID8gbG9jYXRpb25SZXN1bHQgOiBbbG9jYXRpb25SZXN1bHRdKS5maWx0ZXIoKGQpID0+IGQucmFuZ2Uuc3RhcnQgIT0gbnVsbCk7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljOiBDb252ZXJ0IGFuIHtBcnJheX0gb2Yge0xvY2F0aW9ufSBvYmplY3RzIGludG8gYW4gQXJyYXkgb2Yge0RlZmluaXRpb259cy5cbiAgICpcbiAgICogQHBhcmFtIGxvY2F0aW9ucyBBbiB7QXJyYXl9IG9mIHtMb2NhdGlvbn0gb2JqZWN0cyB0byBiZSBjb252ZXJ0ZWQuXG4gICAqIEBwYXJhbSBsYW5ndWFnZU5hbWUgVGhlIG5hbWUgb2YgdGhlIGxhbmd1YWdlIHRoZXNlIG9iamVjdHMgYXJlIHdyaXR0ZW4gaW4uXG4gICAqIEByZXR1cm5zIEFuIHtBcnJheX0gb2Yge0RlZmluaXRpb259cyB0aGF0IHJlcHJlc2VudGVkIHRoZSBjb252ZXJ0ZWQge0xvY2F0aW9ufXMuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGNvbnZlcnRMb2NhdGlvbnNUb0RlZmluaXRpb25zKGxvY2F0aW9uczogTG9jYXRpb25bXSwgbGFuZ3VhZ2VOYW1lOiBzdHJpbmcpOiBhdG9tSWRlLkRlZmluaXRpb25bXSB7XG4gICAgcmV0dXJuIGxvY2F0aW9ucy5tYXAoKGQpID0+ICh7XG4gICAgICBwYXRoOiBDb252ZXJ0LnVyaVRvUGF0aChkLnVyaSksXG4gICAgICBwb3NpdGlvbjogQ29udmVydC5wb3NpdGlvblRvUG9pbnQoZC5yYW5nZS5zdGFydCksXG4gICAgICByYW5nZTogUmFuZ2UuZnJvbU9iamVjdChDb252ZXJ0LmxzUmFuZ2VUb0F0b21SYW5nZShkLnJhbmdlKSksXG4gICAgICBsYW5ndWFnZTogbGFuZ3VhZ2VOYW1lLFxuICAgIH0pKTtcbiAgfVxufVxuIl19