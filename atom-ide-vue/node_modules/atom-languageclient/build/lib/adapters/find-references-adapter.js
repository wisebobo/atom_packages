"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const convert_1 = require("../convert");
/**
 * Public: Adapts the language server definition provider to the
 * Atom IDE UI Definitions package for 'Go To Definition' functionality.
 */
class FindReferencesAdapter {
    /**
     * Public: Determine whether this adapter can be used to adapt a language server
     * based on the serverCapabilities matrix containing a referencesProvider.
     *
     * @param serverCapabilities The {ServerCapabilities} of the language server to consider.
     * @returns A {Boolean} indicating adapter can adapt the server based on the
     *   given serverCapabilities.
     */
    static canAdapt(serverCapabilities) {
        return serverCapabilities.referencesProvider === true;
    }
    /**
     * Public: Get the references for a specific symbol within the document as represented by
     * the {TextEditor} and {Point} within it via the language server.
     *
     * @param connection A {LanguageClientConnection} to the language server that will be queried
     *   for the references.
     * @param editor The Atom {TextEditor} containing the text the references should relate to.
     * @param point The Atom {Point} containing the point within the text the references should relate to.
     * @returns A {Promise} containing a {FindReferencesReturn} with all the references the language server
     *   could find.
     */
    getReferences(connection, editor, point, projectRoot) {
        return __awaiter(this, void 0, void 0, function* () {
            const locations = yield connection.findReferences(FindReferencesAdapter.createReferenceParams(editor, point));
            if (locations == null) {
                return null;
            }
            const references = locations.map(FindReferencesAdapter.locationToReference);
            return {
                type: 'data',
                baseUri: projectRoot || '',
                referencedSymbolName: FindReferencesAdapter.getReferencedSymbolName(editor, point, references),
                references,
            };
        });
    }
    /**
     * Public: Create a {ReferenceParams} from a given {TextEditor} for a specific {Point}.
     *
     * @param editor A {TextEditor} that represents the document.
     * @param point A {Point} within the document.
     * @returns A {ReferenceParams} built from the given parameters.
     */
    static createReferenceParams(editor, point) {
        return {
            textDocument: convert_1.default.editorToTextDocumentIdentifier(editor),
            position: convert_1.default.pointToPosition(point),
            context: { includeDeclaration: true },
        };
    }
    /**
     * Public: Convert a {Location} into a {Reference}.
     *
     * @param location A {Location} to convert.
     * @returns A {Reference} equivalent to the given {Location}.
     */
    static locationToReference(location) {
        return {
            uri: convert_1.default.uriToPath(location.uri),
            name: null,
            range: convert_1.default.lsRangeToAtomRange(location.range),
        };
    }
    /** Public: Get a symbol name from a {TextEditor} for a specific {Point} in the document. */
    static getReferencedSymbolName(editor, point, references) {
        if (references.length === 0) {
            return '';
        }
        const currentReference = references.find((r) => r.range.containsPoint(point)) || references[0];
        return editor.getBuffer().getTextInRange(currentReference.range);
    }
}
exports.default = FindReferencesAdapter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmluZC1yZWZlcmVuY2VzLWFkYXB0ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9saWIvYWRhcHRlcnMvZmluZC1yZWZlcmVuY2VzLWFkYXB0ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFDQSx3Q0FBaUM7QUFZakM7OztHQUdHO0FBQ0gsTUFBcUIscUJBQXFCO0lBQ3hDOzs7Ozs7O09BT0c7SUFDSSxNQUFNLENBQUMsUUFBUSxDQUFDLGtCQUFzQztRQUMzRCxPQUFPLGtCQUFrQixDQUFDLGtCQUFrQixLQUFLLElBQUksQ0FBQztJQUN4RCxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNVLGFBQWEsQ0FDeEIsVUFBb0MsRUFDcEMsTUFBa0IsRUFDbEIsS0FBWSxFQUNaLFdBQTBCOztZQUUxQixNQUFNLFNBQVMsR0FBRyxNQUFNLFVBQVUsQ0FBQyxjQUFjLENBQy9DLHFCQUFxQixDQUFDLHFCQUFxQixDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FDM0QsQ0FBQztZQUNGLElBQUksU0FBUyxJQUFJLElBQUksRUFBRTtnQkFDckIsT0FBTyxJQUFJLENBQUM7YUFDYjtZQUVELE1BQU0sVUFBVSxHQUF3QixTQUFTLENBQUMsR0FBRyxDQUFDLHFCQUFxQixDQUFDLG1CQUFtQixDQUFDLENBQUM7WUFDakcsT0FBTztnQkFDTCxJQUFJLEVBQUUsTUFBTTtnQkFDWixPQUFPLEVBQUUsV0FBVyxJQUFJLEVBQUU7Z0JBQzFCLG9CQUFvQixFQUFFLHFCQUFxQixDQUFDLHVCQUF1QixDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsVUFBVSxDQUFDO2dCQUM5RixVQUFVO2FBQ1gsQ0FBQztRQUNKLENBQUM7S0FBQTtJQUVEOzs7Ozs7T0FNRztJQUNJLE1BQU0sQ0FBQyxxQkFBcUIsQ0FBQyxNQUFrQixFQUFFLEtBQVk7UUFDbEUsT0FBTztZQUNMLFlBQVksRUFBRSxpQkFBTyxDQUFDLDhCQUE4QixDQUFDLE1BQU0sQ0FBQztZQUM1RCxRQUFRLEVBQUUsaUJBQU8sQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDO1lBQ3hDLE9BQU8sRUFBRSxFQUFFLGtCQUFrQixFQUFFLElBQUksRUFBRTtTQUN0QyxDQUFDO0lBQ0osQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ksTUFBTSxDQUFDLG1CQUFtQixDQUFDLFFBQWtCO1FBQ2xELE9BQU87WUFDTCxHQUFHLEVBQUUsaUJBQU8sQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQztZQUNwQyxJQUFJLEVBQUUsSUFBSTtZQUNWLEtBQUssRUFBRSxpQkFBTyxDQUFDLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUM7U0FDbEQsQ0FBQztJQUNKLENBQUM7SUFFRCw0RkFBNEY7SUFDckYsTUFBTSxDQUFDLHVCQUF1QixDQUNuQyxNQUFrQixFQUNsQixLQUFZLEVBQ1osVUFBK0I7UUFFL0IsSUFBSSxVQUFVLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUMzQixPQUFPLEVBQUUsQ0FBQztTQUNYO1FBQ0QsTUFBTSxnQkFBZ0IsR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMvRixPQUFPLE1BQU0sQ0FBQyxTQUFTLEVBQUUsQ0FBQyxjQUFjLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDbkUsQ0FBQztDQUNGO0FBdkZELHdDQXVGQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGF0b21JZGUgZnJvbSAnYXRvbS1pZGUnO1xuaW1wb3J0IENvbnZlcnQgZnJvbSAnLi4vY29udmVydCc7XG5pbXBvcnQge1xuICBQb2ludCxcbiAgVGV4dEVkaXRvcixcbn0gZnJvbSAnYXRvbSc7XG5pbXBvcnQge1xuICBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXG4gIExvY2F0aW9uLFxuICBTZXJ2ZXJDYXBhYmlsaXRpZXMsXG4gIFJlZmVyZW5jZVBhcmFtcyxcbn0gZnJvbSAnLi4vbGFuZ3VhZ2VjbGllbnQnO1xuXG4vKipcbiAqIFB1YmxpYzogQWRhcHRzIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgZGVmaW5pdGlvbiBwcm92aWRlciB0byB0aGVcbiAqIEF0b20gSURFIFVJIERlZmluaXRpb25zIHBhY2thZ2UgZm9yICdHbyBUbyBEZWZpbml0aW9uJyBmdW5jdGlvbmFsaXR5LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaW5kUmVmZXJlbmNlc0FkYXB0ZXIge1xuICAvKipcbiAgICogUHVibGljOiBEZXRlcm1pbmUgd2hldGhlciB0aGlzIGFkYXB0ZXIgY2FuIGJlIHVzZWQgdG8gYWRhcHQgYSBsYW5ndWFnZSBzZXJ2ZXJcbiAgICogYmFzZWQgb24gdGhlIHNlcnZlckNhcGFiaWxpdGllcyBtYXRyaXggY29udGFpbmluZyBhIHJlZmVyZW5jZXNQcm92aWRlci5cbiAgICpcbiAgICogQHBhcmFtIHNlcnZlckNhcGFiaWxpdGllcyBUaGUge1NlcnZlckNhcGFiaWxpdGllc30gb2YgdGhlIGxhbmd1YWdlIHNlcnZlciB0byBjb25zaWRlci5cbiAgICogQHJldHVybnMgQSB7Qm9vbGVhbn0gaW5kaWNhdGluZyBhZGFwdGVyIGNhbiBhZGFwdCB0aGUgc2VydmVyIGJhc2VkIG9uIHRoZVxuICAgKiAgIGdpdmVuIHNlcnZlckNhcGFiaWxpdGllcy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgY2FuQWRhcHQoc2VydmVyQ2FwYWJpbGl0aWVzOiBTZXJ2ZXJDYXBhYmlsaXRpZXMpOiBib29sZWFuIHtcbiAgICByZXR1cm4gc2VydmVyQ2FwYWJpbGl0aWVzLnJlZmVyZW5jZXNQcm92aWRlciA9PT0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWM6IEdldCB0aGUgcmVmZXJlbmNlcyBmb3IgYSBzcGVjaWZpYyBzeW1ib2wgd2l0aGluIHRoZSBkb2N1bWVudCBhcyByZXByZXNlbnRlZCBieVxuICAgKiB0aGUge1RleHRFZGl0b3J9IGFuZCB7UG9pbnR9IHdpdGhpbiBpdCB2aWEgdGhlIGxhbmd1YWdlIHNlcnZlci5cbiAgICpcbiAgICogQHBhcmFtIGNvbm5lY3Rpb24gQSB7TGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9ufSB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRoYXQgd2lsbCBiZSBxdWVyaWVkXG4gICAqICAgZm9yIHRoZSByZWZlcmVuY2VzLlxuICAgKiBAcGFyYW0gZWRpdG9yIFRoZSBBdG9tIHtUZXh0RWRpdG9yfSBjb250YWluaW5nIHRoZSB0ZXh0IHRoZSByZWZlcmVuY2VzIHNob3VsZCByZWxhdGUgdG8uXG4gICAqIEBwYXJhbSBwb2ludCBUaGUgQXRvbSB7UG9pbnR9IGNvbnRhaW5pbmcgdGhlIHBvaW50IHdpdGhpbiB0aGUgdGV4dCB0aGUgcmVmZXJlbmNlcyBzaG91bGQgcmVsYXRlIHRvLlxuICAgKiBAcmV0dXJucyBBIHtQcm9taXNlfSBjb250YWluaW5nIGEge0ZpbmRSZWZlcmVuY2VzUmV0dXJufSB3aXRoIGFsbCB0aGUgcmVmZXJlbmNlcyB0aGUgbGFuZ3VhZ2Ugc2VydmVyXG4gICAqICAgY291bGQgZmluZC5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBnZXRSZWZlcmVuY2VzKFxuICAgIGNvbm5lY3Rpb246IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcbiAgICBlZGl0b3I6IFRleHRFZGl0b3IsXG4gICAgcG9pbnQ6IFBvaW50LFxuICAgIHByb2plY3RSb290OiBzdHJpbmcgfCBudWxsLFxuICApOiBQcm9taXNlPGF0b21JZGUuRmluZFJlZmVyZW5jZXNSZXR1cm4gfCBudWxsPiB7XG4gICAgY29uc3QgbG9jYXRpb25zID0gYXdhaXQgY29ubmVjdGlvbi5maW5kUmVmZXJlbmNlcyhcbiAgICAgIEZpbmRSZWZlcmVuY2VzQWRhcHRlci5jcmVhdGVSZWZlcmVuY2VQYXJhbXMoZWRpdG9yLCBwb2ludCksXG4gICAgKTtcbiAgICBpZiAobG9jYXRpb25zID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHJlZmVyZW5jZXM6IGF0b21JZGUuUmVmZXJlbmNlW10gPSBsb2NhdGlvbnMubWFwKEZpbmRSZWZlcmVuY2VzQWRhcHRlci5sb2NhdGlvblRvUmVmZXJlbmNlKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2RhdGEnLFxuICAgICAgYmFzZVVyaTogcHJvamVjdFJvb3QgfHwgJycsXG4gICAgICByZWZlcmVuY2VkU3ltYm9sTmFtZTogRmluZFJlZmVyZW5jZXNBZGFwdGVyLmdldFJlZmVyZW5jZWRTeW1ib2xOYW1lKGVkaXRvciwgcG9pbnQsIHJlZmVyZW5jZXMpLFxuICAgICAgcmVmZXJlbmNlcyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYzogQ3JlYXRlIGEge1JlZmVyZW5jZVBhcmFtc30gZnJvbSBhIGdpdmVuIHtUZXh0RWRpdG9yfSBmb3IgYSBzcGVjaWZpYyB7UG9pbnR9LlxuICAgKlxuICAgKiBAcGFyYW0gZWRpdG9yIEEge1RleHRFZGl0b3J9IHRoYXQgcmVwcmVzZW50cyB0aGUgZG9jdW1lbnQuXG4gICAqIEBwYXJhbSBwb2ludCBBIHtQb2ludH0gd2l0aGluIHRoZSBkb2N1bWVudC5cbiAgICogQHJldHVybnMgQSB7UmVmZXJlbmNlUGFyYW1zfSBidWlsdCBmcm9tIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBjcmVhdGVSZWZlcmVuY2VQYXJhbXMoZWRpdG9yOiBUZXh0RWRpdG9yLCBwb2ludDogUG9pbnQpOiBSZWZlcmVuY2VQYXJhbXMge1xuICAgIHJldHVybiB7XG4gICAgICB0ZXh0RG9jdW1lbnQ6IENvbnZlcnQuZWRpdG9yVG9UZXh0RG9jdW1lbnRJZGVudGlmaWVyKGVkaXRvciksXG4gICAgICBwb3NpdGlvbjogQ29udmVydC5wb2ludFRvUG9zaXRpb24ocG9pbnQpLFxuICAgICAgY29udGV4dDogeyBpbmNsdWRlRGVjbGFyYXRpb246IHRydWUgfSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYzogQ29udmVydCBhIHtMb2NhdGlvbn0gaW50byBhIHtSZWZlcmVuY2V9LlxuICAgKlxuICAgKiBAcGFyYW0gbG9jYXRpb24gQSB7TG9jYXRpb259IHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIEEge1JlZmVyZW5jZX0gZXF1aXZhbGVudCB0byB0aGUgZ2l2ZW4ge0xvY2F0aW9ufS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbG9jYXRpb25Ub1JlZmVyZW5jZShsb2NhdGlvbjogTG9jYXRpb24pOiBhdG9tSWRlLlJlZmVyZW5jZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVyaTogQ29udmVydC51cmlUb1BhdGgobG9jYXRpb24udXJpKSxcbiAgICAgIG5hbWU6IG51bGwsXG4gICAgICByYW5nZTogQ29udmVydC5sc1JhbmdlVG9BdG9tUmFuZ2UobG9jYXRpb24ucmFuZ2UpLFxuICAgIH07XG4gIH1cblxuICAvKiogUHVibGljOiBHZXQgYSBzeW1ib2wgbmFtZSBmcm9tIGEge1RleHRFZGl0b3J9IGZvciBhIHNwZWNpZmljIHtQb2ludH0gaW4gdGhlIGRvY3VtZW50LiAqL1xuICBwdWJsaWMgc3RhdGljIGdldFJlZmVyZW5jZWRTeW1ib2xOYW1lKFxuICAgIGVkaXRvcjogVGV4dEVkaXRvcixcbiAgICBwb2ludDogUG9pbnQsXG4gICAgcmVmZXJlbmNlczogYXRvbUlkZS5SZWZlcmVuY2VbXSxcbiAgKTogc3RyaW5nIHtcbiAgICBpZiAocmVmZXJlbmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFJlZmVyZW5jZSA9IHJlZmVyZW5jZXMuZmluZCgocikgPT4gci5yYW5nZS5jb250YWluc1BvaW50KHBvaW50KSkgfHwgcmVmZXJlbmNlc1swXTtcbiAgICByZXR1cm4gZWRpdG9yLmdldEJ1ZmZlcigpLmdldFRleHRJblJhbmdlKGN1cnJlbnRSZWZlcmVuY2UucmFuZ2UpO1xuICB9XG59XG4iXX0=