"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.promiseWithTimeout = exports.assertUnreachable = exports.doWithCancellationToken = exports.cancelAndRefreshCancellationToken = exports.escapeRegExp = exports.getWordAtPosition = void 0;
const atom_1 = require("atom");
const vscode_jsonrpc_1 = require("vscode-jsonrpc");
/**
 * Obtain the range of the word at the given editor position.
 * Uses the non-word characters from the position's grammar scope.
 */
function getWordAtPosition(editor, position) {
    const nonWordCharacters = escapeRegExp(editor.getNonWordCharacters(position));
    const range = _getRegexpRangeAtPosition(editor.getBuffer(), position, new RegExp(`^[\t ]*$|[^\\s${nonWordCharacters}]+`, 'g'));
    if (range == null) {
        return new atom_1.Range(position, position);
    }
    return range;
}
exports.getWordAtPosition = getWordAtPosition;
function escapeRegExp(string) {
    // From atom/underscore-plus.
    return string.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
}
exports.escapeRegExp = escapeRegExp;
function _getRegexpRangeAtPosition(buffer, position, wordRegex) {
    const { row, column } = position;
    const rowRange = buffer.rangeForRow(row, false);
    let matchData;
    // Extract the expression from the row text.
    buffer.scanInRange(wordRegex, rowRange, (data) => {
        const { range } = data;
        if (position.isGreaterThanOrEqual(range.start) &&
            // Range endpoints are exclusive.
            position.isLessThan(range.end)) {
            matchData = data;
            data.stop();
            return;
        }
        // Stop the scan if the scanner has passed our position.
        if (range.end.column > column) {
            data.stop();
        }
    });
    return matchData == null ? null : matchData.range;
}
/**
 * For the given connection and cancellationTokens map, cancel the existing
 * CancellationToken for that connection then create and store a new
 * CancellationToken to be used for the current request.
 */
function cancelAndRefreshCancellationToken(key, cancellationTokens) {
    let cancellationToken = cancellationTokens.get(key);
    if (cancellationToken !== undefined && !cancellationToken.token.isCancellationRequested) {
        cancellationToken.cancel();
    }
    cancellationToken = new vscode_jsonrpc_1.CancellationTokenSource();
    cancellationTokens.set(key, cancellationToken);
    return cancellationToken.token;
}
exports.cancelAndRefreshCancellationToken = cancelAndRefreshCancellationToken;
function doWithCancellationToken(key, cancellationTokens, work) {
    return __awaiter(this, void 0, void 0, function* () {
        const token = cancelAndRefreshCancellationToken(key, cancellationTokens);
        const result = yield work(token);
        cancellationTokens.delete(key);
        return result;
    });
}
exports.doWithCancellationToken = doWithCancellationToken;
function assertUnreachable(_) {
    return _;
}
exports.assertUnreachable = assertUnreachable;
function promiseWithTimeout(ms, promise) {
    return new Promise((resolve, reject) => {
        // create a timeout to reject promise if not resolved
        const timer = setTimeout(() => {
            reject(new Error(`Timeout after ${ms}ms`));
        }, ms);
        promise.then((res) => {
            clearTimeout(timer);
            resolve(res);
        }).catch((err) => {
            clearTimeout(timer);
            reject(err);
        });
    });
}
exports.promiseWithTimeout = promiseWithTimeout;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9saWIvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsK0JBTWM7QUFDZCxtREFHd0I7QUFPeEI7OztHQUdHO0FBQ0gsU0FBZ0IsaUJBQWlCLENBQUMsTUFBa0IsRUFBRSxRQUFlO0lBQ25FLE1BQU0saUJBQWlCLEdBQUcsWUFBWSxDQUFDLE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0lBQzlFLE1BQU0sS0FBSyxHQUFHLHlCQUF5QixDQUNyQyxNQUFNLENBQUMsU0FBUyxFQUFFLEVBQ2xCLFFBQVEsRUFDUixJQUFJLE1BQU0sQ0FBQyxpQkFBaUIsaUJBQWlCLElBQUksRUFBRSxHQUFHLENBQUMsQ0FDeEQsQ0FBQztJQUNGLElBQUksS0FBSyxJQUFJLElBQUksRUFBRTtRQUNqQixPQUFPLElBQUksWUFBSyxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQztLQUN0QztJQUNELE9BQU8sS0FBSyxDQUFDO0FBQ2YsQ0FBQztBQVhELDhDQVdDO0FBRUQsU0FBZ0IsWUFBWSxDQUFDLE1BQWM7SUFDekMsNkJBQTZCO0lBQzdCLE9BQU8sTUFBTSxDQUFDLE9BQU8sQ0FBQyx1QkFBdUIsRUFBRSxNQUFNLENBQUMsQ0FBQztBQUN6RCxDQUFDO0FBSEQsb0NBR0M7QUFFRCxTQUFTLHlCQUF5QixDQUFDLE1BQWtCLEVBQUUsUUFBZSxFQUFFLFNBQWlCO0lBQ3ZGLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUcsUUFBUSxDQUFDO0lBQ2pDLE1BQU0sUUFBUSxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ2hELElBQUksU0FBOEMsQ0FBQztJQUNuRCw0Q0FBNEM7SUFDNUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxTQUFTLEVBQUUsUUFBUSxFQUFFLENBQUMsSUFBSSxFQUFFLEVBQUU7UUFDL0MsTUFBTSxFQUFFLEtBQUssRUFBRSxHQUFHLElBQUksQ0FBQztRQUN2QixJQUNFLFFBQVEsQ0FBQyxvQkFBb0IsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDO1lBQzFDLGlDQUFpQztZQUNqQyxRQUFRLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFDOUI7WUFDQSxTQUFTLEdBQUcsSUFBSSxDQUFDO1lBQ2pCLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUNaLE9BQU87U0FDUjtRQUNELHdEQUF3RDtRQUN4RCxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsTUFBTSxHQUFHLE1BQU0sRUFBRTtZQUM3QixJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7U0FDYjtJQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0gsT0FBTyxTQUFTLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUM7QUFDcEQsQ0FBQztBQUVEOzs7O0dBSUc7QUFDSCxTQUFnQixpQ0FBaUMsQ0FDL0MsR0FBTSxFQUNOLGtCQUF1RDtJQUV2RCxJQUFJLGlCQUFpQixHQUFHLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNwRCxJQUFJLGlCQUFpQixLQUFLLFNBQVMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEtBQUssQ0FBQyx1QkFBdUIsRUFBRTtRQUN2RixpQkFBaUIsQ0FBQyxNQUFNLEVBQUUsQ0FBQztLQUM1QjtJQUVELGlCQUFpQixHQUFHLElBQUksd0NBQXVCLEVBQUUsQ0FBQztJQUNsRCxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLGlCQUFpQixDQUFDLENBQUM7SUFDL0MsT0FBTyxpQkFBaUIsQ0FBQyxLQUFLLENBQUM7QUFDakMsQ0FBQztBQVpELDhFQVlDO0FBRUQsU0FBc0IsdUJBQXVCLENBQzNDLEdBQU8sRUFDUCxrQkFBd0QsRUFDeEQsSUFBK0M7O1FBRS9DLE1BQU0sS0FBSyxHQUFHLGlDQUFpQyxDQUFDLEdBQUcsRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO1FBQ3pFLE1BQU0sTUFBTSxHQUFPLE1BQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3JDLGtCQUFrQixDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUMvQixPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0NBQUE7QUFURCwwREFTQztBQUVELFNBQWdCLGlCQUFpQixDQUFDLENBQVE7SUFDeEMsT0FBTyxDQUFDLENBQUM7QUFDWCxDQUFDO0FBRkQsOENBRUM7QUFFRCxTQUFnQixrQkFBa0IsQ0FBSSxFQUFVLEVBQUUsT0FBbUI7SUFDbkUsT0FBTyxJQUFJLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsRUFBRTtRQUNyQyxxREFBcUQ7UUFDckQsTUFBTSxLQUFLLEdBQUcsVUFBVSxDQUFDLEdBQUcsRUFBRTtZQUM1QixNQUFNLENBQUMsSUFBSSxLQUFLLENBQUMsaUJBQWlCLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUM3QyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFFUCxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUU7WUFDbkIsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3BCLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNmLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFO1lBQ2YsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3BCLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNkLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDO0FBZkQsZ0RBZUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBQb2ludCxcbiAgVGV4dEJ1ZmZlcixcbiAgVGV4dEVkaXRvcixcbiAgUmFuZ2UsXG4gIEJ1ZmZlclNjYW5SZXN1bHQsXG59IGZyb20gJ2F0b20nO1xuaW1wb3J0IHtcbiAgQ2FuY2VsbGF0aW9uVG9rZW4sXG4gIENhbmNlbGxhdGlvblRva2VuU291cmNlLFxufSBmcm9tICd2c2NvZGUtanNvbnJwYyc7XG5cbmV4cG9ydCB0eXBlIFJlcG9ydEJ1c3lXaGlsZSA9IDxUPihcbiAgdGl0bGU6IHN0cmluZyxcbiAgZjogKCkgPT4gUHJvbWlzZTxUPixcbikgPT4gUHJvbWlzZTxUPjtcblxuLyoqXG4gKiBPYnRhaW4gdGhlIHJhbmdlIG9mIHRoZSB3b3JkIGF0IHRoZSBnaXZlbiBlZGl0b3IgcG9zaXRpb24uXG4gKiBVc2VzIHRoZSBub24td29yZCBjaGFyYWN0ZXJzIGZyb20gdGhlIHBvc2l0aW9uJ3MgZ3JhbW1hciBzY29wZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFdvcmRBdFBvc2l0aW9uKGVkaXRvcjogVGV4dEVkaXRvciwgcG9zaXRpb246IFBvaW50KTogUmFuZ2Uge1xuICBjb25zdCBub25Xb3JkQ2hhcmFjdGVycyA9IGVzY2FwZVJlZ0V4cChlZGl0b3IuZ2V0Tm9uV29yZENoYXJhY3RlcnMocG9zaXRpb24pKTtcbiAgY29uc3QgcmFuZ2UgPSBfZ2V0UmVnZXhwUmFuZ2VBdFBvc2l0aW9uKFxuICAgIGVkaXRvci5nZXRCdWZmZXIoKSxcbiAgICBwb3NpdGlvbixcbiAgICBuZXcgUmVnRXhwKGBeW1xcdCBdKiR8W15cXFxccyR7bm9uV29yZENoYXJhY3RlcnN9XStgLCAnZycpLFxuICApO1xuICBpZiAocmFuZ2UgPT0gbnVsbCkge1xuICAgIHJldHVybiBuZXcgUmFuZ2UocG9zaXRpb24sIHBvc2l0aW9uKTtcbiAgfVxuICByZXR1cm4gcmFuZ2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nOiBzdHJpbmcpOiBzdHJpbmcge1xuICAvLyBGcm9tIGF0b20vdW5kZXJzY29yZS1wbHVzLlxuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1stL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcbn1cblxuZnVuY3Rpb24gX2dldFJlZ2V4cFJhbmdlQXRQb3NpdGlvbihidWZmZXI6IFRleHRCdWZmZXIsIHBvc2l0aW9uOiBQb2ludCwgd29yZFJlZ2V4OiBSZWdFeHApOiBSYW5nZSB8IG51bGwge1xuICBjb25zdCB7IHJvdywgY29sdW1uIH0gPSBwb3NpdGlvbjtcbiAgY29uc3Qgcm93UmFuZ2UgPSBidWZmZXIucmFuZ2VGb3JSb3cocm93LCBmYWxzZSk7XG4gIGxldCBtYXRjaERhdGE6IEJ1ZmZlclNjYW5SZXN1bHQgfCB1bmRlZmluZWQgfCBudWxsO1xuICAvLyBFeHRyYWN0IHRoZSBleHByZXNzaW9uIGZyb20gdGhlIHJvdyB0ZXh0LlxuICBidWZmZXIuc2NhbkluUmFuZ2Uod29yZFJlZ2V4LCByb3dSYW5nZSwgKGRhdGEpID0+IHtcbiAgICBjb25zdCB7IHJhbmdlIH0gPSBkYXRhO1xuICAgIGlmIChcbiAgICAgIHBvc2l0aW9uLmlzR3JlYXRlclRoYW5PckVxdWFsKHJhbmdlLnN0YXJ0KSAmJlxuICAgICAgLy8gUmFuZ2UgZW5kcG9pbnRzIGFyZSBleGNsdXNpdmUuXG4gICAgICBwb3NpdGlvbi5pc0xlc3NUaGFuKHJhbmdlLmVuZClcbiAgICApIHtcbiAgICAgIG1hdGNoRGF0YSA9IGRhdGE7XG4gICAgICBkYXRhLnN0b3AoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gU3RvcCB0aGUgc2NhbiBpZiB0aGUgc2Nhbm5lciBoYXMgcGFzc2VkIG91ciBwb3NpdGlvbi5cbiAgICBpZiAocmFuZ2UuZW5kLmNvbHVtbiA+IGNvbHVtbikge1xuICAgICAgZGF0YS5zdG9wKCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG1hdGNoRGF0YSA9PSBudWxsID8gbnVsbCA6IG1hdGNoRGF0YS5yYW5nZTtcbn1cblxuLyoqXG4gKiBGb3IgdGhlIGdpdmVuIGNvbm5lY3Rpb24gYW5kIGNhbmNlbGxhdGlvblRva2VucyBtYXAsIGNhbmNlbCB0aGUgZXhpc3RpbmdcbiAqIENhbmNlbGxhdGlvblRva2VuIGZvciB0aGF0IGNvbm5lY3Rpb24gdGhlbiBjcmVhdGUgYW5kIHN0b3JlIGEgbmV3XG4gKiBDYW5jZWxsYXRpb25Ub2tlbiB0byBiZSB1c2VkIGZvciB0aGUgY3VycmVudCByZXF1ZXN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FuY2VsQW5kUmVmcmVzaENhbmNlbGxhdGlvblRva2VuPFQgZXh0ZW5kcyBvYmplY3Q+KFxuICBrZXk6IFQsXG4gIGNhbmNlbGxhdGlvblRva2VuczogV2Vha01hcDxULCBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZT4pOiBDYW5jZWxsYXRpb25Ub2tlbiB7XG5cbiAgbGV0IGNhbmNlbGxhdGlvblRva2VuID0gY2FuY2VsbGF0aW9uVG9rZW5zLmdldChrZXkpO1xuICBpZiAoY2FuY2VsbGF0aW9uVG9rZW4gIT09IHVuZGVmaW5lZCAmJiAhY2FuY2VsbGF0aW9uVG9rZW4udG9rZW4uaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQpIHtcbiAgICBjYW5jZWxsYXRpb25Ub2tlbi5jYW5jZWwoKTtcbiAgfVxuXG4gIGNhbmNlbGxhdGlvblRva2VuID0gbmV3IENhbmNlbGxhdGlvblRva2VuU291cmNlKCk7XG4gIGNhbmNlbGxhdGlvblRva2Vucy5zZXQoa2V5LCBjYW5jZWxsYXRpb25Ub2tlbik7XG4gIHJldHVybiBjYW5jZWxsYXRpb25Ub2tlbi50b2tlbjtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRvV2l0aENhbmNlbGxhdGlvblRva2VuPFQxIGV4dGVuZHMgb2JqZWN0LCBUMj4oXG4gIGtleTogVDEsXG4gIGNhbmNlbGxhdGlvblRva2VuczogV2Vha01hcDxUMSwgQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2U+LFxuICB3b3JrOiAodG9rZW46IENhbmNlbGxhdGlvblRva2VuKSA9PiBQcm9taXNlPFQyPixcbik6IFByb21pc2U8VDI+IHtcbiAgY29uc3QgdG9rZW4gPSBjYW5jZWxBbmRSZWZyZXNoQ2FuY2VsbGF0aW9uVG9rZW4oa2V5LCBjYW5jZWxsYXRpb25Ub2tlbnMpO1xuICBjb25zdCByZXN1bHQ6IFQyID0gYXdhaXQgd29yayh0b2tlbik7XG4gIGNhbmNlbGxhdGlvblRva2Vucy5kZWxldGUoa2V5KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFVucmVhY2hhYmxlKF86IG5ldmVyKTogbmV2ZXIge1xuICByZXR1cm4gXztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb21pc2VXaXRoVGltZW91dDxUPihtczogbnVtYmVyLCBwcm9taXNlOiBQcm9taXNlPFQ+KTogUHJvbWlzZTxUPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgLy8gY3JlYXRlIGEgdGltZW91dCB0byByZWplY3QgcHJvbWlzZSBpZiBub3QgcmVzb2x2ZWRcbiAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcihgVGltZW91dCBhZnRlciAke21zfW1zYCkpO1xuICAgIH0sIG1zKTtcblxuICAgIHByb21pc2UudGhlbigocmVzKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgcmVzb2x2ZShyZXMpO1xuICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9KTtcbiAgfSk7XG59XG4iXX0=