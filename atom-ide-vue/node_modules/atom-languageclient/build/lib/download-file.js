"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
/**
 * Public: Download a file and store it on a file system using streaming with appropriate progress callback.
 *
 * @param sourceUrl Url to download from.
 * @param targetFile File path to save to.
 * @param progressCallback Callback function that will be given a {ByteProgressCallback} object containing
 *   both bytesDone and percent.
 * @param length File length in bytes if you want percentage progress indication and the server is
 *   unable to provide a Content-Length header and whitelist CORS access via a
 *   `Access-Control-Expose-Headers "content-length"` header.
 * @returns A {Promise} that will accept when complete.
 */
exports.default = (function downloadFile(sourceUrl, targetFile, progressCallback, length) {
    return __awaiter(this, void 0, void 0, function* () {
        const request = new Request(sourceUrl, {
            headers: new Headers({ 'Content-Type': 'application/octet-stream' }),
        });
        const response = yield fetch(request);
        if (!response.ok) {
            throw Error(`Unable to download, server returned ${response.status} ${response.statusText}`);
        }
        const body = response.body;
        if (body == null) {
            throw Error('No response body');
        }
        const finalLength = length || parseInt(response.headers.get('Content-Length') || '0', 10);
        const reader = body.getReader();
        const writer = fs.createWriteStream(targetFile);
        yield streamWithProgress(finalLength, reader, writer, progressCallback);
        writer.end();
    });
});
/**
 * Stream from a {ReadableStreamReader} to a {WriteStream} with progress callback.
 *
 * @param length File length in bytes.
 * @param reader A {ReadableStreamReader} to read from.
 * @param writer A {WriteStream} to write to.
 * @param progressCallback Callback function that will be given a {ByteProgressCallback} object containing
 *   both bytesDone and percent.
 * @returns A {Promise} that will accept when complete.
 */
function streamWithProgress(length, reader, writer, progressCallback) {
    return __awaiter(this, void 0, void 0, function* () {
        let bytesDone = 0;
        // eslint-disable-next-line no-constant-condition
        while (true) {
            const result = yield reader.read();
            if (result.done) {
                if (progressCallback != null) {
                    progressCallback(length, 100);
                }
                return;
            }
            const chunk = result.value;
            if (chunk == null) {
                throw Error('Empty chunk received during download');
            }
            else {
                writer.write(Buffer.from(chunk));
                if (progressCallback != null) {
                    bytesDone += chunk.byteLength;
                    const percent = length === 0 ? undefined : Math.floor(bytesDone / length * 100);
                    progressCallback(bytesDone, percent);
                }
            }
        }
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG93bmxvYWQtZmlsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9kb3dubG9hZC1maWxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUEseUJBQXlCO0FBRXpCOzs7Ozs7Ozs7OztHQVdHO0FBQ0gsa0JBQWUsQ0FBQyxTQUFlLFlBQVksQ0FDekMsU0FBaUIsRUFDakIsVUFBa0IsRUFDbEIsZ0JBQXVDLEVBQ3ZDLE1BQWU7O1FBRWYsTUFBTSxPQUFPLEdBQUcsSUFBSSxPQUFPLENBQUMsU0FBUyxFQUFFO1lBQ3JDLE9BQU8sRUFBRSxJQUFJLE9BQU8sQ0FBQyxFQUFFLGNBQWMsRUFBRSwwQkFBMEIsRUFBRSxDQUFDO1NBQ3JFLENBQUMsQ0FBQztRQUVILE1BQU0sUUFBUSxHQUFHLE1BQU0sS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3RDLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRSxFQUFFO1lBQ2hCLE1BQU0sS0FBSyxDQUFDLHVDQUF1QyxRQUFRLENBQUMsTUFBTSxJQUFJLFFBQVEsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDO1NBQzlGO1FBRUQsTUFBTSxJQUFJLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQztRQUMzQixJQUFJLElBQUksSUFBSSxJQUFJLEVBQUU7WUFDaEIsTUFBTSxLQUFLLENBQUMsa0JBQWtCLENBQUMsQ0FBQztTQUNqQztRQUVELE1BQU0sV0FBVyxHQUFHLE1BQU0sSUFBSSxRQUFRLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDMUYsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ2hDLE1BQU0sTUFBTSxHQUFHLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUVoRCxNQUFNLGtCQUFrQixDQUFDLFdBQVcsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLGdCQUFnQixDQUFDLENBQUM7UUFDeEUsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBQ2YsQ0FBQztDQUFBLENBQUMsQ0FBQztBQUVIOzs7Ozs7Ozs7R0FTRztBQUNILFNBQWUsa0JBQWtCLENBQy9CLE1BQWMsRUFDZCxNQUE0QixFQUM1QixNQUFzQixFQUN0QixnQkFBdUM7O1FBRXZDLElBQUksU0FBUyxHQUFHLENBQUMsQ0FBQztRQUVsQixpREFBaUQ7UUFDakQsT0FBTyxJQUFJLEVBQUU7WUFDWCxNQUFNLE1BQU0sR0FBRyxNQUFNLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUNuQyxJQUFJLE1BQU0sQ0FBQyxJQUFJLEVBQUU7Z0JBQ2YsSUFBSSxnQkFBZ0IsSUFBSSxJQUFJLEVBQUU7b0JBQzVCLGdCQUFnQixDQUFDLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQztpQkFDL0I7Z0JBQ0QsT0FBTzthQUNSO1lBRUQsTUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQztZQUMzQixJQUFJLEtBQUssSUFBSSxJQUFJLEVBQUU7Z0JBQ2pCLE1BQU0sS0FBSyxDQUFDLHNDQUFzQyxDQUFDLENBQUM7YUFDckQ7aUJBQU07Z0JBQ0wsTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7Z0JBQ2pDLElBQUksZ0JBQWdCLElBQUksSUFBSSxFQUFFO29CQUM1QixTQUFTLElBQUksS0FBSyxDQUFDLFVBQVUsQ0FBQztvQkFDOUIsTUFBTSxPQUFPLEdBQXVCLE1BQU0sS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDO29CQUNwRyxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7aUJBQ3RDO2FBQ0Y7U0FDRjtJQUNILENBQUM7Q0FBQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcblxuLyoqXG4gKiBQdWJsaWM6IERvd25sb2FkIGEgZmlsZSBhbmQgc3RvcmUgaXQgb24gYSBmaWxlIHN5c3RlbSB1c2luZyBzdHJlYW1pbmcgd2l0aCBhcHByb3ByaWF0ZSBwcm9ncmVzcyBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0gc291cmNlVXJsIFVybCB0byBkb3dubG9hZCBmcm9tLlxuICogQHBhcmFtIHRhcmdldEZpbGUgRmlsZSBwYXRoIHRvIHNhdmUgdG8uXG4gKiBAcGFyYW0gcHJvZ3Jlc3NDYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZ2l2ZW4gYSB7Qnl0ZVByb2dyZXNzQ2FsbGJhY2t9IG9iamVjdCBjb250YWluaW5nXG4gKiAgIGJvdGggYnl0ZXNEb25lIGFuZCBwZXJjZW50LlxuICogQHBhcmFtIGxlbmd0aCBGaWxlIGxlbmd0aCBpbiBieXRlcyBpZiB5b3Ugd2FudCBwZXJjZW50YWdlIHByb2dyZXNzIGluZGljYXRpb24gYW5kIHRoZSBzZXJ2ZXIgaXNcbiAqICAgdW5hYmxlIHRvIHByb3ZpZGUgYSBDb250ZW50LUxlbmd0aCBoZWFkZXIgYW5kIHdoaXRlbGlzdCBDT1JTIGFjY2VzcyB2aWEgYVxuICogICBgQWNjZXNzLUNvbnRyb2wtRXhwb3NlLUhlYWRlcnMgXCJjb250ZW50LWxlbmd0aFwiYCBoZWFkZXIuXG4gKiBAcmV0dXJucyBBIHtQcm9taXNlfSB0aGF0IHdpbGwgYWNjZXB0IHdoZW4gY29tcGxldGUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IChhc3luYyBmdW5jdGlvbiBkb3dubG9hZEZpbGUoXG4gIHNvdXJjZVVybDogc3RyaW5nLFxuICB0YXJnZXRGaWxlOiBzdHJpbmcsXG4gIHByb2dyZXNzQ2FsbGJhY2s/OiBCeXRlUHJvZ3Jlc3NDYWxsYmFjayxcbiAgbGVuZ3RoPzogbnVtYmVyLFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdChzb3VyY2VVcmwsIHtcbiAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyh7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyB9KSxcbiAgfSk7XG5cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChyZXF1ZXN0KTtcbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIHRocm93IEVycm9yKGBVbmFibGUgdG8gZG93bmxvYWQsIHNlcnZlciByZXR1cm5lZCAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICB9XG5cbiAgY29uc3QgYm9keSA9IHJlc3BvbnNlLmJvZHk7XG4gIGlmIChib2R5ID09IG51bGwpIHtcbiAgICB0aHJvdyBFcnJvcignTm8gcmVzcG9uc2UgYm9keScpO1xuICB9XG5cbiAgY29uc3QgZmluYWxMZW5ndGggPSBsZW5ndGggfHwgcGFyc2VJbnQocmVzcG9uc2UuaGVhZGVycy5nZXQoJ0NvbnRlbnQtTGVuZ3RoJykgfHwgJzAnLCAxMCk7XG4gIGNvbnN0IHJlYWRlciA9IGJvZHkuZ2V0UmVhZGVyKCk7XG4gIGNvbnN0IHdyaXRlciA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKHRhcmdldEZpbGUpO1xuXG4gIGF3YWl0IHN0cmVhbVdpdGhQcm9ncmVzcyhmaW5hbExlbmd0aCwgcmVhZGVyLCB3cml0ZXIsIHByb2dyZXNzQ2FsbGJhY2spO1xuICB3cml0ZXIuZW5kKCk7XG59KTtcblxuLyoqXG4gKiBTdHJlYW0gZnJvbSBhIHtSZWFkYWJsZVN0cmVhbVJlYWRlcn0gdG8gYSB7V3JpdGVTdHJlYW19IHdpdGggcHJvZ3Jlc3MgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIGxlbmd0aCBGaWxlIGxlbmd0aCBpbiBieXRlcy5cbiAqIEBwYXJhbSByZWFkZXIgQSB7UmVhZGFibGVTdHJlYW1SZWFkZXJ9IHRvIHJlYWQgZnJvbS5cbiAqIEBwYXJhbSB3cml0ZXIgQSB7V3JpdGVTdHJlYW19IHRvIHdyaXRlIHRvLlxuICogQHBhcmFtIHByb2dyZXNzQ2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGdpdmVuIGEge0J5dGVQcm9ncmVzc0NhbGxiYWNrfSBvYmplY3QgY29udGFpbmluZ1xuICogICBib3RoIGJ5dGVzRG9uZSBhbmQgcGVyY2VudC5cbiAqIEByZXR1cm5zIEEge1Byb21pc2V9IHRoYXQgd2lsbCBhY2NlcHQgd2hlbiBjb21wbGV0ZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc3RyZWFtV2l0aFByb2dyZXNzKFxuICBsZW5ndGg6IG51bWJlcixcbiAgcmVhZGVyOiBSZWFkYWJsZVN0cmVhbVJlYWRlcixcbiAgd3JpdGVyOiBmcy5Xcml0ZVN0cmVhbSxcbiAgcHJvZ3Jlc3NDYWxsYmFjaz86IEJ5dGVQcm9ncmVzc0NhbGxiYWNrLFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGxldCBieXRlc0RvbmUgPSAwO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgaWYgKHByb2dyZXNzQ2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKGxlbmd0aCwgMTAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjaHVuayA9IHJlc3VsdC52YWx1ZTtcbiAgICBpZiAoY2h1bmsgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0VtcHR5IGNodW5rIHJlY2VpdmVkIGR1cmluZyBkb3dubG9hZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3cml0ZXIud3JpdGUoQnVmZmVyLmZyb20oY2h1bmspKTtcbiAgICAgIGlmIChwcm9ncmVzc0NhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgYnl0ZXNEb25lICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgIGNvbnN0IHBlcmNlbnQ6IG51bWJlciB8IHVuZGVmaW5lZCA9IGxlbmd0aCA9PT0gMCA/IHVuZGVmaW5lZCA6IE1hdGguZmxvb3IoYnl0ZXNEb25lIC8gbGVuZ3RoICogMTAwKTtcbiAgICAgICAgcHJvZ3Jlc3NDYWxsYmFjayhieXRlc0RvbmUsIHBlcmNlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFB1YmxpYzogUHJvZ3Jlc3MgY2FsbGJhY2sgZnVuY3Rpb24gc2lnbmF0dXJlIGluZGljYXRpbmcgdGhlIGJ5dGVzRG9uZSBhbmRcbiAqIG9wdGlvbmFsIHBlcmNlbnRhZ2Ugd2hlbiBsZW5ndGggaXMga25vd24uXG4gKi9cbmV4cG9ydCB0eXBlIEJ5dGVQcm9ncmVzc0NhbGxiYWNrID0gKGJ5dGVzRG9uZTogbnVtYmVyLCBwZXJjZW50PzogbnVtYmVyKSA9PiB2b2lkO1xuIl19